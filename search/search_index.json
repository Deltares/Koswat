{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Koswat \u00b6 Official documentation read the docs for Koswat","title":"Koswat"},{"location":"index.html#koswat","text":"Official documentation read the docs for Koswat","title":"Koswat"},{"location":"changelog.html","text":"Release-2023 (2023-11-07) \u00b6 Feat \u00b6 Added order_strategy submodule for determining reinforcement features across a dike traject based on default order Added new class to better handle / generate the location-reinforcement matrix Fix \u00b6 improve rounding improve rounding improve rounding show cost per km if no locations present add @property to total_cost add @property to total_cost add @property to total_cost test on presence of construction costs correct return type Added logic to plot new layer surfaces when they are either a LineString or a MultiLineString corrected berm width calculations (#114) corrected berm width calculations merge leftovers rename \"raise\" to \"surtax\" throughout KOSWAT rename \"raise\" to \"surtax\" throughout KOSWAT correct symbol name correct symbol name typo comment typo comment Added logic to avoid creating added / removed layers geometries when there were no modifications Added default values as math.nan for koswatscenario We now replace not-provided values from a KoswatScenario when calculating new reinforcements docu corrections docu corrections docu corrections v0.15.0 (2025-06-27) \u00b6 Feat \u00b6 extend calculations for having berm as part of input profile (#218) use costs_with_surtax in infra strategy (#229) 213 extend summary report with reinforcement order (#215) generate strategies intermediate results (#208) create strategy to select reinforcements based on subclusters (#206) 90 implement logic to sort/filter the reinforcement types (#202) create new strategy based on infrastructures (#197) 188 add reinforcements to strategy_input (#201) Modify strategylocationreinforcement to include all related costs (#199) export locations report into a shp file instead (#185) [161] Connect koswat workflow with infrastructures cost export (#167) update summarycostscsvfombuilder (#166) 155 create new SummaryInfrastructureCostsCsvFomBuilder (#157) [132] add infrastructure cost to the multilocation profile report (#151) 143 add the new input profile to the corresponding builders include expanding ini (#144) refactor surroundings fom and dom [132] (#140) 136 add new measure (profile) 129 remove deprecated shapely.geometry.almost_equals Fix \u00b6 postcreatecommand correct construction of StrategyReinforcementInput instances (#228) 224 ordering strategy not as expected (#225) Corrected buffering lower limit and max reinforcement for clustering. (#222) improve performance infra cost summation (#205) 180 adjust calculation wall length for stability screen and cofferdam (#187) 171 total infrastructure cost in summary costcsv seems to be wrong (#182) 177 errors when getting total infrastructure per zone (#178) surroundings matrix does not include entries between infrastructures (#173) v0.14.1 (2023-11-08) \u00b6 v0.14.0 (2023-11-07) \u00b6 Feat \u00b6 Added order_strategy submodule for determining reinforcement features across a dike traject based on default order Added new class to better handle / generate the location-reinforcement matrix Fix \u00b6 improve rounding improve rounding improve rounding show cost per km if no locations present add @property to total_cost add @property to total_cost add @property to total_cost test on presence of construction costs correct return type Added logic to plot new layer surfaces when they are either a LineString or a MultiLineString corrected berm width calculations (#114) corrected berm width calculations merge leftovers rename \"raise\" to \"surtax\" throughout KOSWAT rename \"raise\" to \"surtax\" throughout KOSWAT correct symbol name correct symbol name typo comment typo comment Added logic to avoid creating added / removed layers geometries when there were no modifications Added default values as math.nan for koswatscenario We now replace not-provided values from a KoswatScenario when calculating new reinforcements docu corrections docu corrections docu corrections v0.13.0 (2023-01-31) \u00b6 Feat \u00b6 volume_cost_parameters_builder.py : We now calculate the costs based on the ini input file v0.12.1 (2023-01-27) \u00b6 Fix \u00b6 calc_library.py : Standrad reinforcement calculation now uses a different method to make sure the added geometry is normalized v0.12.0 (2023-01-26) \u00b6 Feat \u00b6 koswat/cost_report : Koswat Summary now includes all available locations even if they are not suitable for any reinforcement profile. Adapted the rest of the classes to generate a proper matrix also during export v0.11.7 (2023-01-25) \u00b6 Fix \u00b6 calc_library.py : We now check whether the last point intersects with the line drawn between the first two points to avoid precission issues v0.11.6 (2023-01-25) \u00b6 Fix \u00b6 calc_library.py;koswat_coating_layer_builder.py : We now round up the coordinates of the calculated layers to avoid precision issues calc_library.py : Corrected collection of surface points, added extra plot for reinforced profiles v0.11.5 (2023-01-12) \u00b6 Fix \u00b6 calc_library : Small correction to avoid crashing when trying to order multiline strings v0.11.4 (2023-01-12) \u00b6 Fix \u00b6 standard_reinforcement_layers_wrapper_builder : Fixed sand layer added surface not being correct calc_library.py : After doing a geometry union the resulting geometry gets now their points in order v0.11.3 (2023-01-12) \u00b6 Fix \u00b6 koswat/configuration : Fixed creation of scenarios based on selected dike sections v0.11.2 (2022-12-21) \u00b6 v0.11.1 (2022-12-20) \u00b6 Fix \u00b6 koswat/ main .py : Renamed main file to fit to python main expected module v0.11.0 (2022-12-20) \u00b6 Feat \u00b6 koswat/koswat_handler.py : We now accept a log_output argument to specify the directory where to save the koswat run log. v0.10.0 (2022-12-20) \u00b6 Feat \u00b6 koswat/configuration/converters : Created converters fom to dom koswat/configuration/io/converters/ : Added configuration converters for the analysis section. We can now generate input profiles from the ini files koswat/configuration/io/csv : Added import of KoswatInputProfiles KoswatHandler;KoswatLogger : Added handler and logger for koswat runs from CLI Fix \u00b6 koswat/geometries/calc_library.py : We now order the points of the geometries so that calculations can be done correctly koswat/calculations : Corrected profile calculation for all types and their tests. These changes come directly from Peter de Grave koswat/configuration/io/koswat_run_settings_importer.py : corrected filtering of selected input profiles koswat_dike_locations_shp_reader.py : Fixed enumerating a filtered list instead of filtering after enumerating KoswatSurroundingsConverter : Fixed return as it was only giving the latest mapped FOM configuration/io/converters : Fixed return of data and adapted tests koswat_analysis_converter.py : Small fix to converter koswat_General_settings.py : Fix validation for surroundings koswat/calculations : Fixed calculations due to new profile input property KoswatMaterialType : Minor fix regarding usage of new KoswatMaterialType KoswatMaterialType : Adapted code to use the enum instead of strings Refactor \u00b6 koswat/configuration/io : Moved converters into io koswat/dike/surroundings/io/shp : Moved shp reader and fom to surroundings module koswat/configuration : Integrating mapping of files to fom's during settings import koswat/dike/surroundings/io : Moved previous CSV reader into a concrete module within dike/surroundings. Created protocols for csv reading so it can be repurposed KoswatMaterialType : Made koswat material into an enum. Adapted code overall in the source v0.9.0 (2022-12-12) \u00b6 Feat \u00b6 KoswatGeneralSettings : Created DOM for koswat general settings configuration KoswatConfigurationIniImporter : We can now map all different ini fom classes to the config class koswat/configuration : Created koswat configuration module and related class KoswatConfiguration to encapsulate all require information for a koswat analysis KoswatScenarioIniFom : It is now possible to read a KoswatScenarioIniFom from file KoswatDikeSelectionIniFom : It is now possible to read a Dike Selection INI file into its corresponding FOM KoswatCostsIniFom : Added logic to fully implement reading of a KoswatCostsIniFom file KoswatCostsIniFom : Added koswat costs ini file KoswatIniReader : Created koswat ini reader and initial approach to reading the general Koswat INI file Fix \u00b6 KoswatCosts : Added class conversion to dictionary Refactor \u00b6 koswat/configuration/models : Moved configuration data object models into their own module. Fixed / grouped imports KoswatDikeSelection : Koswat dike selection now implements a new type KoswatDikeSelectionTxtFom with related reader koswat_scenario : Moved koswat scenario into koswat/configuration koswat/io : Adapted export / import fom protocol v0.8.2 (2022-12-09) \u00b6 Fix \u00b6 KoswatLayerProtocol : we now have two different geometries for a layer, so that the profile with the layer and the stand alone representation of it are better reached v0.8.1 (2022-11-21) \u00b6 Fix \u00b6 SummaryMatrixCsvExporter : We now provide NANs when volume parameter is not defined summary_matrix_csv_exporter : We now correctly export all required information to the csv for the user v0.8.0 (2022-11-19) \u00b6 Feat \u00b6 KoswatPlotContext : Created plot context handler so it's easier to initialize and close plots v0.7.0 (2022-11-18) \u00b6 Feat \u00b6 koswat/cost_report/io/plots/ : Added module for cost_report export plots logic koswat_profile_plot.py : We can now set a unique color for layers_wrapper and profile plots koswat/plots/dike/ : Extracted dike plotting logic into separate classes koswat/plots/geometries : Created module with plotting for regular geometries from shapely Fix \u00b6 koswat/plots/utils.py : Replaced wrapper as it is not a good approach characteristic_points_builder.py : Resolved a circular dependency Refactor \u00b6 koswat/calculations/io/ : Extracted plot exporters from calculations into their corresponding directory koswat/plots : Create concrete module for plotting koswat/io : Moved io files into their corresponding modules v0.6.0 (2022-11-11) \u00b6 Feat \u00b6 VolumeCalculationParameters : Included all operations required to for volume calculation ReinforcementProfileProtocol : Added new property to retrieve the new ground level surface OutsideSlopeReinforcementLayersWrapperBuilder : Added builder for for the outside slope reinforcement layers wrapper StandardReinforcemetnLayersWrapperBuilder : Added logic to generate the geometries of a standard reinforcement dike ReinforcementLayersWrapper : We now have dedicated builders for the LayersWrapper associated with a Reinforcement ReinforcementProfileBuilderProtocol : Created protocol for better hierarchy CoatingLayerCostReport : Extended usage of previous StandardLayerCostReport so that other reinforcements can also use it Added logic to extract the surface of a layer LayerCostReportProtocol;StandardLayerCostReportBuilder : Extracted standard layer cost report builder logic into separate class. Added protocol to represent the layer cost reports koswat/geometries; standard_layer_cost_report : Implemented logic for StandardLayer cost calculation OutsideSlopeReinforcementProfileProtocol;StandardReinforcementProfileProtocol : Added protocols to represent the different types of reinforcement - per volume; Added tests for factory LayerCostReportbuilderFactory : Added logic to retrieve the corresponding LayerCostReportBuilderProtocol; Adapted tests and related imports LayerCostReportBuilderFactory : Introduced layer cost report builder factory for the different types of volume calculators available Fix \u00b6 PipingWallReinforcementProfileCalculation : Solved wrong calculation of the Length Piping Wall StabilityWallReinforcementProfileCalculation : Corrected calculation of the length stability wall property StabilityWall calculation was not properly mapped OutsideSlopeProfileCostReportBuilder : Now we properly calculate the added core layer OutsideSlopeProfileCostReportBuilder : Calculation of the 'kistdam' layers is now done properly Refactor \u00b6 koswat/calculations : Moved calculations into their respecitve reinforcement types Starting to move logic of added / removed layers to the calculation module cost_report : Moved layer factory to profile factory as the logic should be in a higher level v0.5.1 (2022-10-11) \u00b6 Fix \u00b6 SummaryMatrixCsvExporter : We now export the locations in order of import v0.5.0 (2022-10-11) \u00b6 Feat \u00b6 SummaryMatrixCsvExporter : We now also export the CsvFom into a file SummaryMatrixCsvFom;SummaryMatrixCsvExporter : Added Summary Matrix Csv Fom and Exporter initial logic CofferDamInputProfile : Added concrete input profile for CofferDamReinforcementProfile calculations/cofferdam;CofferdamReinforcementProfileCalculation;CofferdamReinforcementProfile : Added Cofferdam Reinforcement Profile and Calculation to the calculations module. Added information to the summary to also build their report. StabilityWallInputProfile;StabilityWallReinforcementProfileCalculation : Created both concrete input profile and profile calculation for StabilityWallReinforcementProfile StabilityWallReinforcemetnProfile : Added StabilityWallReinforcementProfile type PipingWallInputProfile : Created dedicated input profile for PipingWall KoswatInputProfileProtocol : Made a Koswat Input Profile protocol to manage better concrete input profiles. Adapted existing code and tests PipingWallReinforcementProfileCalculation : Added calculation for PipingWall Reinforcement Profile PipingWall : Added PipingWallReinforcementProfile class ReinforcementProfileProtocol : Introduced ReinforcementProfileProtocol as a sub protocol of KoswatProfileProtocol. Adapted existent classes and tests. Moved existing calculations into calculations\\soil Fix \u00b6 CofferdamReinforcementProfileCalculation : P4 x coordinate set to 0 for all builds from this calculation KoswatProfileBuilder : Removed paramater from build method to make it complier to the BuilderProtocol v0.4.0 (2022-10-07) \u00b6 Feat \u00b6 MultiLocationMultiProfileCostBuilder : Added new report to summarize reports of profile per location. ListMultiLocationProfileCostBuilder : It is now possible to make a report for multiple locations and multiple possible profiles KoswatBuildingsPolderside.get_classify_surroundings : We can now retrieve all points classified by their distance to the closest building KoswatSurroundings : Added wrapper class for surroundings and a builder for it. Extended other koswat/surrounding builder classes to be initialized from files. KoswatCsvFomBuilder;Koswat\\surroundings : We can now map the csv data to surrounding points and their distances to buildings. Adapted related code KoswatCsvReader : It is possible to read a CSV file into a FileObjectModelProtocol instance of KoswatCsvFom . Added new methods to fom and reader protocols, adapted related classes KoswatShpReader : Added KoswatShpReader to read from a shapefile. Added reader protocol and io module Refactor \u00b6 koswat/surroundings : Moved files into separate module dike : Renamed profiles module to dike for a more coherent approach cost_report : Moved directories into a better tree structure koswat/cost_report : Seggregated module into builders and reports. koswat/cost_report : Extracted reports into their own modules ProfileCostBuilder : Profile cost builder is independent of the profile type. All types of new profiles are calculated and then a report is done for each of them\" v0.3.0 (2022-10-03) \u00b6 Feat \u00b6 CharacteristicPoints : Created characteristic points to replace the previous 'ProtocolSide' related classes. Introduced builder to allow initial or reinforced profile creation KoswatLayersBuilder : We now can create layers based on the provided depth ProfileReinforcementCostBuilder : Generates a cost report for the new profile based on the extra required volume KoswatReport : Added KoswatReport to generate costs overviews It is now possible to create layers from a dictionary koswat_layers;koswat_profile_builder : Added new class to represent the layers of a profile, their material and so on. koswat/calculations : Added profile reinforcement calculation koswat/profiles : Added koswat profiles and related properties. They can now be built from an input profile v0.2.0 (2022-09-27) \u00b6 Feat \u00b6 koswat : Initial commit. Created Initial architecture and basic tests for the structure given. Added version control through commitizen","title":"Changelog"},{"location":"changelog.html#release-2023-2023-11-07","text":"","title":"Release-2023 (2023-11-07)"},{"location":"changelog.html#feat","text":"Added order_strategy submodule for determining reinforcement features across a dike traject based on default order Added new class to better handle / generate the location-reinforcement matrix","title":"Feat"},{"location":"changelog.html#fix","text":"improve rounding improve rounding improve rounding show cost per km if no locations present add @property to total_cost add @property to total_cost add @property to total_cost test on presence of construction costs correct return type Added logic to plot new layer surfaces when they are either a LineString or a MultiLineString corrected berm width calculations (#114) corrected berm width calculations merge leftovers rename \"raise\" to \"surtax\" throughout KOSWAT rename \"raise\" to \"surtax\" throughout KOSWAT correct symbol name correct symbol name typo comment typo comment Added logic to avoid creating added / removed layers geometries when there were no modifications Added default values as math.nan for koswatscenario We now replace not-provided values from a KoswatScenario when calculating new reinforcements docu corrections docu corrections docu corrections","title":"Fix"},{"location":"changelog.html#v0150-2025-06-27","text":"","title":"v0.15.0 (2025-06-27)"},{"location":"changelog.html#feat_1","text":"extend calculations for having berm as part of input profile (#218) use costs_with_surtax in infra strategy (#229) 213 extend summary report with reinforcement order (#215) generate strategies intermediate results (#208) create strategy to select reinforcements based on subclusters (#206) 90 implement logic to sort/filter the reinforcement types (#202) create new strategy based on infrastructures (#197) 188 add reinforcements to strategy_input (#201) Modify strategylocationreinforcement to include all related costs (#199) export locations report into a shp file instead (#185) [161] Connect koswat workflow with infrastructures cost export (#167) update summarycostscsvfombuilder (#166) 155 create new SummaryInfrastructureCostsCsvFomBuilder (#157) [132] add infrastructure cost to the multilocation profile report (#151) 143 add the new input profile to the corresponding builders include expanding ini (#144) refactor surroundings fom and dom [132] (#140) 136 add new measure (profile) 129 remove deprecated shapely.geometry.almost_equals","title":"Feat"},{"location":"changelog.html#fix_1","text":"postcreatecommand correct construction of StrategyReinforcementInput instances (#228) 224 ordering strategy not as expected (#225) Corrected buffering lower limit and max reinforcement for clustering. (#222) improve performance infra cost summation (#205) 180 adjust calculation wall length for stability screen and cofferdam (#187) 171 total infrastructure cost in summary costcsv seems to be wrong (#182) 177 errors when getting total infrastructure per zone (#178) surroundings matrix does not include entries between infrastructures (#173)","title":"Fix"},{"location":"changelog.html#v0141-2023-11-08","text":"","title":"v0.14.1 (2023-11-08)"},{"location":"changelog.html#v0140-2023-11-07","text":"","title":"v0.14.0 (2023-11-07)"},{"location":"changelog.html#feat_2","text":"Added order_strategy submodule for determining reinforcement features across a dike traject based on default order Added new class to better handle / generate the location-reinforcement matrix","title":"Feat"},{"location":"changelog.html#fix_2","text":"improve rounding improve rounding improve rounding show cost per km if no locations present add @property to total_cost add @property to total_cost add @property to total_cost test on presence of construction costs correct return type Added logic to plot new layer surfaces when they are either a LineString or a MultiLineString corrected berm width calculations (#114) corrected berm width calculations merge leftovers rename \"raise\" to \"surtax\" throughout KOSWAT rename \"raise\" to \"surtax\" throughout KOSWAT correct symbol name correct symbol name typo comment typo comment Added logic to avoid creating added / removed layers geometries when there were no modifications Added default values as math.nan for koswatscenario We now replace not-provided values from a KoswatScenario when calculating new reinforcements docu corrections docu corrections docu corrections","title":"Fix"},{"location":"changelog.html#v0130-2023-01-31","text":"","title":"v0.13.0 (2023-01-31)"},{"location":"changelog.html#feat_3","text":"volume_cost_parameters_builder.py : We now calculate the costs based on the ini input file","title":"Feat"},{"location":"changelog.html#v0121-2023-01-27","text":"","title":"v0.12.1 (2023-01-27)"},{"location":"changelog.html#fix_3","text":"calc_library.py : Standrad reinforcement calculation now uses a different method to make sure the added geometry is normalized","title":"Fix"},{"location":"changelog.html#v0120-2023-01-26","text":"","title":"v0.12.0 (2023-01-26)"},{"location":"changelog.html#feat_4","text":"koswat/cost_report : Koswat Summary now includes all available locations even if they are not suitable for any reinforcement profile. Adapted the rest of the classes to generate a proper matrix also during export","title":"Feat"},{"location":"changelog.html#v0117-2023-01-25","text":"","title":"v0.11.7 (2023-01-25)"},{"location":"changelog.html#fix_4","text":"calc_library.py : We now check whether the last point intersects with the line drawn between the first two points to avoid precission issues","title":"Fix"},{"location":"changelog.html#v0116-2023-01-25","text":"","title":"v0.11.6 (2023-01-25)"},{"location":"changelog.html#fix_5","text":"calc_library.py;koswat_coating_layer_builder.py : We now round up the coordinates of the calculated layers to avoid precision issues calc_library.py : Corrected collection of surface points, added extra plot for reinforced profiles","title":"Fix"},{"location":"changelog.html#v0115-2023-01-12","text":"","title":"v0.11.5 (2023-01-12)"},{"location":"changelog.html#fix_6","text":"calc_library : Small correction to avoid crashing when trying to order multiline strings","title":"Fix"},{"location":"changelog.html#v0114-2023-01-12","text":"","title":"v0.11.4 (2023-01-12)"},{"location":"changelog.html#fix_7","text":"standard_reinforcement_layers_wrapper_builder : Fixed sand layer added surface not being correct calc_library.py : After doing a geometry union the resulting geometry gets now their points in order","title":"Fix"},{"location":"changelog.html#v0113-2023-01-12","text":"","title":"v0.11.3 (2023-01-12)"},{"location":"changelog.html#fix_8","text":"koswat/configuration : Fixed creation of scenarios based on selected dike sections","title":"Fix"},{"location":"changelog.html#v0112-2022-12-21","text":"","title":"v0.11.2 (2022-12-21)"},{"location":"changelog.html#v0111-2022-12-20","text":"","title":"v0.11.1 (2022-12-20)"},{"location":"changelog.html#fix_9","text":"koswat/ main .py : Renamed main file to fit to python main expected module","title":"Fix"},{"location":"changelog.html#v0110-2022-12-20","text":"","title":"v0.11.0 (2022-12-20)"},{"location":"changelog.html#feat_5","text":"koswat/koswat_handler.py : We now accept a log_output argument to specify the directory where to save the koswat run log.","title":"Feat"},{"location":"changelog.html#v0100-2022-12-20","text":"","title":"v0.10.0 (2022-12-20)"},{"location":"changelog.html#feat_6","text":"koswat/configuration/converters : Created converters fom to dom koswat/configuration/io/converters/ : Added configuration converters for the analysis section. We can now generate input profiles from the ini files koswat/configuration/io/csv : Added import of KoswatInputProfiles KoswatHandler;KoswatLogger : Added handler and logger for koswat runs from CLI","title":"Feat"},{"location":"changelog.html#fix_10","text":"koswat/geometries/calc_library.py : We now order the points of the geometries so that calculations can be done correctly koswat/calculations : Corrected profile calculation for all types and their tests. These changes come directly from Peter de Grave koswat/configuration/io/koswat_run_settings_importer.py : corrected filtering of selected input profiles koswat_dike_locations_shp_reader.py : Fixed enumerating a filtered list instead of filtering after enumerating KoswatSurroundingsConverter : Fixed return as it was only giving the latest mapped FOM configuration/io/converters : Fixed return of data and adapted tests koswat_analysis_converter.py : Small fix to converter koswat_General_settings.py : Fix validation for surroundings koswat/calculations : Fixed calculations due to new profile input property KoswatMaterialType : Minor fix regarding usage of new KoswatMaterialType KoswatMaterialType : Adapted code to use the enum instead of strings","title":"Fix"},{"location":"changelog.html#refactor","text":"koswat/configuration/io : Moved converters into io koswat/dike/surroundings/io/shp : Moved shp reader and fom to surroundings module koswat/configuration : Integrating mapping of files to fom's during settings import koswat/dike/surroundings/io : Moved previous CSV reader into a concrete module within dike/surroundings. Created protocols for csv reading so it can be repurposed KoswatMaterialType : Made koswat material into an enum. Adapted code overall in the source","title":"Refactor"},{"location":"changelog.html#v090-2022-12-12","text":"","title":"v0.9.0 (2022-12-12)"},{"location":"changelog.html#feat_7","text":"KoswatGeneralSettings : Created DOM for koswat general settings configuration KoswatConfigurationIniImporter : We can now map all different ini fom classes to the config class koswat/configuration : Created koswat configuration module and related class KoswatConfiguration to encapsulate all require information for a koswat analysis KoswatScenarioIniFom : It is now possible to read a KoswatScenarioIniFom from file KoswatDikeSelectionIniFom : It is now possible to read a Dike Selection INI file into its corresponding FOM KoswatCostsIniFom : Added logic to fully implement reading of a KoswatCostsIniFom file KoswatCostsIniFom : Added koswat costs ini file KoswatIniReader : Created koswat ini reader and initial approach to reading the general Koswat INI file","title":"Feat"},{"location":"changelog.html#fix_11","text":"KoswatCosts : Added class conversion to dictionary","title":"Fix"},{"location":"changelog.html#refactor_1","text":"koswat/configuration/models : Moved configuration data object models into their own module. Fixed / grouped imports KoswatDikeSelection : Koswat dike selection now implements a new type KoswatDikeSelectionTxtFom with related reader koswat_scenario : Moved koswat scenario into koswat/configuration koswat/io : Adapted export / import fom protocol","title":"Refactor"},{"location":"changelog.html#v082-2022-12-09","text":"","title":"v0.8.2 (2022-12-09)"},{"location":"changelog.html#fix_12","text":"KoswatLayerProtocol : we now have two different geometries for a layer, so that the profile with the layer and the stand alone representation of it are better reached","title":"Fix"},{"location":"changelog.html#v081-2022-11-21","text":"","title":"v0.8.1 (2022-11-21)"},{"location":"changelog.html#fix_13","text":"SummaryMatrixCsvExporter : We now provide NANs when volume parameter is not defined summary_matrix_csv_exporter : We now correctly export all required information to the csv for the user","title":"Fix"},{"location":"changelog.html#v080-2022-11-19","text":"","title":"v0.8.0 (2022-11-19)"},{"location":"changelog.html#feat_8","text":"KoswatPlotContext : Created plot context handler so it's easier to initialize and close plots","title":"Feat"},{"location":"changelog.html#v070-2022-11-18","text":"","title":"v0.7.0 (2022-11-18)"},{"location":"changelog.html#feat_9","text":"koswat/cost_report/io/plots/ : Added module for cost_report export plots logic koswat_profile_plot.py : We can now set a unique color for layers_wrapper and profile plots koswat/plots/dike/ : Extracted dike plotting logic into separate classes koswat/plots/geometries : Created module with plotting for regular geometries from shapely","title":"Feat"},{"location":"changelog.html#fix_14","text":"koswat/plots/utils.py : Replaced wrapper as it is not a good approach characteristic_points_builder.py : Resolved a circular dependency","title":"Fix"},{"location":"changelog.html#refactor_2","text":"koswat/calculations/io/ : Extracted plot exporters from calculations into their corresponding directory koswat/plots : Create concrete module for plotting koswat/io : Moved io files into their corresponding modules","title":"Refactor"},{"location":"changelog.html#v060-2022-11-11","text":"","title":"v0.6.0 (2022-11-11)"},{"location":"changelog.html#feat_10","text":"VolumeCalculationParameters : Included all operations required to for volume calculation ReinforcementProfileProtocol : Added new property to retrieve the new ground level surface OutsideSlopeReinforcementLayersWrapperBuilder : Added builder for for the outside slope reinforcement layers wrapper StandardReinforcemetnLayersWrapperBuilder : Added logic to generate the geometries of a standard reinforcement dike ReinforcementLayersWrapper : We now have dedicated builders for the LayersWrapper associated with a Reinforcement ReinforcementProfileBuilderProtocol : Created protocol for better hierarchy CoatingLayerCostReport : Extended usage of previous StandardLayerCostReport so that other reinforcements can also use it Added logic to extract the surface of a layer LayerCostReportProtocol;StandardLayerCostReportBuilder : Extracted standard layer cost report builder logic into separate class. Added protocol to represent the layer cost reports koswat/geometries; standard_layer_cost_report : Implemented logic for StandardLayer cost calculation OutsideSlopeReinforcementProfileProtocol;StandardReinforcementProfileProtocol : Added protocols to represent the different types of reinforcement - per volume; Added tests for factory LayerCostReportbuilderFactory : Added logic to retrieve the corresponding LayerCostReportBuilderProtocol; Adapted tests and related imports LayerCostReportBuilderFactory : Introduced layer cost report builder factory for the different types of volume calculators available","title":"Feat"},{"location":"changelog.html#fix_15","text":"PipingWallReinforcementProfileCalculation : Solved wrong calculation of the Length Piping Wall StabilityWallReinforcementProfileCalculation : Corrected calculation of the length stability wall property StabilityWall calculation was not properly mapped OutsideSlopeProfileCostReportBuilder : Now we properly calculate the added core layer OutsideSlopeProfileCostReportBuilder : Calculation of the 'kistdam' layers is now done properly","title":"Fix"},{"location":"changelog.html#refactor_3","text":"koswat/calculations : Moved calculations into their respecitve reinforcement types Starting to move logic of added / removed layers to the calculation module cost_report : Moved layer factory to profile factory as the logic should be in a higher level","title":"Refactor"},{"location":"changelog.html#v051-2022-10-11","text":"","title":"v0.5.1 (2022-10-11)"},{"location":"changelog.html#fix_16","text":"SummaryMatrixCsvExporter : We now export the locations in order of import","title":"Fix"},{"location":"changelog.html#v050-2022-10-11","text":"","title":"v0.5.0 (2022-10-11)"},{"location":"changelog.html#feat_11","text":"SummaryMatrixCsvExporter : We now also export the CsvFom into a file SummaryMatrixCsvFom;SummaryMatrixCsvExporter : Added Summary Matrix Csv Fom and Exporter initial logic CofferDamInputProfile : Added concrete input profile for CofferDamReinforcementProfile calculations/cofferdam;CofferdamReinforcementProfileCalculation;CofferdamReinforcementProfile : Added Cofferdam Reinforcement Profile and Calculation to the calculations module. Added information to the summary to also build their report. StabilityWallInputProfile;StabilityWallReinforcementProfileCalculation : Created both concrete input profile and profile calculation for StabilityWallReinforcementProfile StabilityWallReinforcemetnProfile : Added StabilityWallReinforcementProfile type PipingWallInputProfile : Created dedicated input profile for PipingWall KoswatInputProfileProtocol : Made a Koswat Input Profile protocol to manage better concrete input profiles. Adapted existing code and tests PipingWallReinforcementProfileCalculation : Added calculation for PipingWall Reinforcement Profile PipingWall : Added PipingWallReinforcementProfile class ReinforcementProfileProtocol : Introduced ReinforcementProfileProtocol as a sub protocol of KoswatProfileProtocol. Adapted existent classes and tests. Moved existing calculations into calculations\\soil","title":"Feat"},{"location":"changelog.html#fix_17","text":"CofferdamReinforcementProfileCalculation : P4 x coordinate set to 0 for all builds from this calculation KoswatProfileBuilder : Removed paramater from build method to make it complier to the BuilderProtocol","title":"Fix"},{"location":"changelog.html#v040-2022-10-07","text":"","title":"v0.4.0 (2022-10-07)"},{"location":"changelog.html#feat_12","text":"MultiLocationMultiProfileCostBuilder : Added new report to summarize reports of profile per location. ListMultiLocationProfileCostBuilder : It is now possible to make a report for multiple locations and multiple possible profiles KoswatBuildingsPolderside.get_classify_surroundings : We can now retrieve all points classified by their distance to the closest building KoswatSurroundings : Added wrapper class for surroundings and a builder for it. Extended other koswat/surrounding builder classes to be initialized from files. KoswatCsvFomBuilder;Koswat\\surroundings : We can now map the csv data to surrounding points and their distances to buildings. Adapted related code KoswatCsvReader : It is possible to read a CSV file into a FileObjectModelProtocol instance of KoswatCsvFom . Added new methods to fom and reader protocols, adapted related classes KoswatShpReader : Added KoswatShpReader to read from a shapefile. Added reader protocol and io module","title":"Feat"},{"location":"changelog.html#refactor_4","text":"koswat/surroundings : Moved files into separate module dike : Renamed profiles module to dike for a more coherent approach cost_report : Moved directories into a better tree structure koswat/cost_report : Seggregated module into builders and reports. koswat/cost_report : Extracted reports into their own modules ProfileCostBuilder : Profile cost builder is independent of the profile type. All types of new profiles are calculated and then a report is done for each of them\"","title":"Refactor"},{"location":"changelog.html#v030-2022-10-03","text":"","title":"v0.3.0 (2022-10-03)"},{"location":"changelog.html#feat_13","text":"CharacteristicPoints : Created characteristic points to replace the previous 'ProtocolSide' related classes. Introduced builder to allow initial or reinforced profile creation KoswatLayersBuilder : We now can create layers based on the provided depth ProfileReinforcementCostBuilder : Generates a cost report for the new profile based on the extra required volume KoswatReport : Added KoswatReport to generate costs overviews It is now possible to create layers from a dictionary koswat_layers;koswat_profile_builder : Added new class to represent the layers of a profile, their material and so on. koswat/calculations : Added profile reinforcement calculation koswat/profiles : Added koswat profiles and related properties. They can now be built from an input profile","title":"Feat"},{"location":"changelog.html#v020-2022-09-27","text":"","title":"v0.2.0 (2022-09-27)"},{"location":"changelog.html#feat_14","text":"koswat : Initial commit. Created Initial architecture and basic tests for the structure given. Added version control through commitizen","title":"Feat"},{"location":"installation.html","text":"Installation \u00b6 Important! : The following installation steps are written based on a Windows environment. When using other systems (which should be possible) it might be required to use different commands. However, the fundamental of the installation steps should remain the same. This meaning, no additional packages or libraries should be required. If problems would arose during your installation, please contact the maintainers of the tool. For users \u00b6 When you only require the koswat package to be used as a whole, and not for development , we advise to directly use the latest greatest release, or directly the latest available version from master there are different ways to do so: Latest available master : pip install git+https://github.com/Deltares/Koswat.git Specific Koswat version, add @version-tag to the previous command, for instance install tag v0.11.0 ( MVP pre-release): pip install git+https://github.com/Deltares/Koswat.git@v0.11.0 | You can also do the above with a commit-hash for development branches (e.g.: @0504c06 ) Using docker (requires checking the repository in a directory): cd <your koswat checked out directory> docker build -t koswat:latest -f Dockerimage . docker run -it koswat bash For developers \u00b6 If you want to contribute to this project please check our contributing wiki section .","title":"Installation"},{"location":"installation.html#installation","text":"Important! : The following installation steps are written based on a Windows environment. When using other systems (which should be possible) it might be required to use different commands. However, the fundamental of the installation steps should remain the same. This meaning, no additional packages or libraries should be required. If problems would arose during your installation, please contact the maintainers of the tool.","title":"Installation"},{"location":"installation.html#for-users","text":"When you only require the koswat package to be used as a whole, and not for development , we advise to directly use the latest greatest release, or directly the latest available version from master there are different ways to do so: Latest available master : pip install git+https://github.com/Deltares/Koswat.git Specific Koswat version, add @version-tag to the previous command, for instance install tag v0.11.0 ( MVP pre-release): pip install git+https://github.com/Deltares/Koswat.git@v0.11.0 | You can also do the above with a commit-hash for development branches (e.g.: @0504c06 ) Using docker (requires checking the repository in a directory): cd <your koswat checked out directory> docker build -t koswat:latest -f Dockerimage . docker run -it koswat bash","title":"For users"},{"location":"installation.html#for-developers","text":"If you want to contribute to this project please check our contributing wiki section .","title":"For developers"},{"location":"user_manual.html","text":"User manual \u00b6 As a command line tool \u00b6 When using Koswat as a package you can run it directly from the command line as follows: python -m koswat --input_file path\\\\to\\\\your\\\\koswat.ini --log_output path\\\\to\\\\your\\\\output\\\\dir The arguments are: --input_file (required): Absolute path to the location of your general koswat.ini file. --log_output (optional): Absolute path to the location of where the koswat.log will be written. If not specified it will be written at the root of the execution directory. It is also possible to check all the above possibilities via the --help argument in the command line: python -m koswat --help As a sandbox \u00b6 It is entirely possible to make a custom Koswat analysis using the tool as a sandbox. This means, through a script calling the different classes to generate an analysis. As a simple example, we can rewrite the acceptance test test_given_surrounding_files_run_calculations_for_all_included_profiles : from koswat.dike.profile.koswat_input_profile_base import KoswatInputProfileBase from koswat.dike.material.koswat_material_type import KoswatMaterialType from koswat.configuration.settings.koswat_scenario import KoswatScenario from koswat.dike.profile import KoswatProfileBase , KoswatProfileBuilder from koswat.cost_report.summary import KoswatSummary , KoswatSummaryBuilder from koswat.configuration.settings.koswat_run_scenario_settings import ( KoswatRunScenarioSettings , ) from koswat.cost_report.io.summary.koswat_summary_exporter import KoswatSummaryExporter from koswat.cost_report.io.plots.multi_location_profile_comparison_plot_exporter import ( MultiLocationProfileComparisonPlotExporter , ) from koswat.dike_reinforcements import ReinforcementProfileBuilderFactory # 1. Define input data. _input_dir = Path ( \"C: \\\\ my_koswat_input_dir\" ) _output_dir = Path ( \"C: \\\\ my_koswat_results\" ) _shp_trajects_file = ( _input_dir / \"Dijkvak\" / \"Dijkringlijnen_KOSWAT_Totaal_2017_10_3_Dijkvak.shp\" ) assert _shp_trajects_file . is_file () ## Define input profile case input_profile_case = KoswatInputProfileBase () input_profile_case . dike_section = \"test_data\" input_profile_case . waterside_ground_level = 0 input_profile_case . waterside_slope = 3 input_profile_case . waterside_berm_width = 0 input_profile_case . waterside_berm_height = 0 input_profile_case . crest_height = 6 input_profile_case . crest_width = 5 input_profile_case . polderside_slope = 3 input_profile_case . polderside_berm_height = 0 input_profile_case . polderside_berm_width = 0 input_profile_case . polderside_ground_level = 0 input_profile_case . pleistocene = - 5 input_profile_case . aquifer = - 2 ## Define the scenario case scenario_case = KoswatScenario () scenario_case . scenario_name = \"\" scenario_case . scenario_section = \"\" scenario_case . d_h = 1 scenario_case . d_s = 10 scenario_case . d_p = 30 scenario_case . crest_width = 5 scenario_case . waterside_slope = 3 ## Define the layers case layers_case = dict ( base_layer = dict ( material = KoswatMaterialType . SAND ), coating_layers = [ dict ( material = KoswatMaterialType . GRASS , depth = 0.3 ), dict ( material = KoswatMaterialType . CLAY , depth = 0.5 ), ], ) ## Import surroundings (TODO: update with latest implementation of SurroundingsWrapperCollectionImporter) _surroundings_importer = KoswatSurroundingsImporter () _surroundings_importer . traject_loc_shp_file = _shp_trajects_file _surroundings = _surroundings_importer . import_from ( _test_dir )[ 0 ] assert isinstance ( scenario_case , KoswatScenario ) _base_koswat_profile = KoswatProfileBuilder . with_data ( dict ( input_profile_data = input_profile_case , layers_data = layers_case , profile_type = KoswatProfileBase , ) ) . build () ## Define the run settings based on the previous calculated parameters. _run_settings = KoswatRunScenarioSettings () _run_settings . scenario = scenario_case _run_settings . surroundings = _surroundings _run_settings . input_profile_case = _base_koswat_profile # 2. Run summary _multi_loc_multi_prof_cost_builder = KoswatSummaryBuilder () _multi_loc_multi_prof_cost_builder . run_scenario_settings = _run_settings _summary = _multi_loc_multi_prof_cost_builder . build () KoswatSummaryExporter () . export ( _summary , _output_dir ) # 3. Generate plots assert isinstance ( _summary , KoswatSummary ) assert any ( _summary . locations_profile_report_list ) for ( _reinforcement_profile ) in ReinforcementProfileBuilderFactory . get_available_reinforcements (): assert any ( isinstance ( _rep_profile . profile_cost_report . reinforced_profile , _reinforcement_profile , ) for _rep_profile in _summary . locations_profile_report_list ), f \"Profile type { _reinforcement_profile . __name__ } not found.\" for _multi_report in _summary . locations_profile_report_list : _mlp_plot = MultiLocationProfileComparisonPlotExporter () _mlp_plot . cost_report = _multi_report _mlp_plot . export_dir = _output_dir _mlp_plot . export ()","title":"User manual"},{"location":"user_manual.html#user-manual","text":"","title":"User manual"},{"location":"user_manual.html#as-a-command-line-tool","text":"When using Koswat as a package you can run it directly from the command line as follows: python -m koswat --input_file path\\\\to\\\\your\\\\koswat.ini --log_output path\\\\to\\\\your\\\\output\\\\dir The arguments are: --input_file (required): Absolute path to the location of your general koswat.ini file. --log_output (optional): Absolute path to the location of where the koswat.log will be written. If not specified it will be written at the root of the execution directory. It is also possible to check all the above possibilities via the --help argument in the command line: python -m koswat --help","title":"As a command line tool"},{"location":"user_manual.html#as-a-sandbox","text":"It is entirely possible to make a custom Koswat analysis using the tool as a sandbox. This means, through a script calling the different classes to generate an analysis. As a simple example, we can rewrite the acceptance test test_given_surrounding_files_run_calculations_for_all_included_profiles : from koswat.dike.profile.koswat_input_profile_base import KoswatInputProfileBase from koswat.dike.material.koswat_material_type import KoswatMaterialType from koswat.configuration.settings.koswat_scenario import KoswatScenario from koswat.dike.profile import KoswatProfileBase , KoswatProfileBuilder from koswat.cost_report.summary import KoswatSummary , KoswatSummaryBuilder from koswat.configuration.settings.koswat_run_scenario_settings import ( KoswatRunScenarioSettings , ) from koswat.cost_report.io.summary.koswat_summary_exporter import KoswatSummaryExporter from koswat.cost_report.io.plots.multi_location_profile_comparison_plot_exporter import ( MultiLocationProfileComparisonPlotExporter , ) from koswat.dike_reinforcements import ReinforcementProfileBuilderFactory # 1. Define input data. _input_dir = Path ( \"C: \\\\ my_koswat_input_dir\" ) _output_dir = Path ( \"C: \\\\ my_koswat_results\" ) _shp_trajects_file = ( _input_dir / \"Dijkvak\" / \"Dijkringlijnen_KOSWAT_Totaal_2017_10_3_Dijkvak.shp\" ) assert _shp_trajects_file . is_file () ## Define input profile case input_profile_case = KoswatInputProfileBase () input_profile_case . dike_section = \"test_data\" input_profile_case . waterside_ground_level = 0 input_profile_case . waterside_slope = 3 input_profile_case . waterside_berm_width = 0 input_profile_case . waterside_berm_height = 0 input_profile_case . crest_height = 6 input_profile_case . crest_width = 5 input_profile_case . polderside_slope = 3 input_profile_case . polderside_berm_height = 0 input_profile_case . polderside_berm_width = 0 input_profile_case . polderside_ground_level = 0 input_profile_case . pleistocene = - 5 input_profile_case . aquifer = - 2 ## Define the scenario case scenario_case = KoswatScenario () scenario_case . scenario_name = \"\" scenario_case . scenario_section = \"\" scenario_case . d_h = 1 scenario_case . d_s = 10 scenario_case . d_p = 30 scenario_case . crest_width = 5 scenario_case . waterside_slope = 3 ## Define the layers case layers_case = dict ( base_layer = dict ( material = KoswatMaterialType . SAND ), coating_layers = [ dict ( material = KoswatMaterialType . GRASS , depth = 0.3 ), dict ( material = KoswatMaterialType . CLAY , depth = 0.5 ), ], ) ## Import surroundings (TODO: update with latest implementation of SurroundingsWrapperCollectionImporter) _surroundings_importer = KoswatSurroundingsImporter () _surroundings_importer . traject_loc_shp_file = _shp_trajects_file _surroundings = _surroundings_importer . import_from ( _test_dir )[ 0 ] assert isinstance ( scenario_case , KoswatScenario ) _base_koswat_profile = KoswatProfileBuilder . with_data ( dict ( input_profile_data = input_profile_case , layers_data = layers_case , profile_type = KoswatProfileBase , ) ) . build () ## Define the run settings based on the previous calculated parameters. _run_settings = KoswatRunScenarioSettings () _run_settings . scenario = scenario_case _run_settings . surroundings = _surroundings _run_settings . input_profile_case = _base_koswat_profile # 2. Run summary _multi_loc_multi_prof_cost_builder = KoswatSummaryBuilder () _multi_loc_multi_prof_cost_builder . run_scenario_settings = _run_settings _summary = _multi_loc_multi_prof_cost_builder . build () KoswatSummaryExporter () . export ( _summary , _output_dir ) # 3. Generate plots assert isinstance ( _summary , KoswatSummary ) assert any ( _summary . locations_profile_report_list ) for ( _reinforcement_profile ) in ReinforcementProfileBuilderFactory . get_available_reinforcements (): assert any ( isinstance ( _rep_profile . profile_cost_report . reinforced_profile , _reinforcement_profile , ) for _rep_profile in _summary . locations_profile_report_list ), f \"Profile type { _reinforcement_profile . __name__ } not found.\" for _multi_report in _summary . locations_profile_report_list : _mlp_plot = MultiLocationProfileComparisonPlotExporter () _mlp_plot . cost_report = _multi_report _mlp_plot . export_dir = _output_dir _mlp_plot . export ()","title":"As a sandbox"},{"location":"reference/koswat_architecture.html","text":"Koswat design \u00b6 In general, the architecture of this package is based on the following principles: Single responsibility principle, component hierarchy . Open-closed principle, inheritance . Interface segregation principle, protocols . Component-module hierarchy \u00b6 We cluster entities into modules (components) that represent their domain and have minimal dependencies with others components, this way the modules can be accessed when operating Koswat as a sandbox. Within each component we apply the same principle and create sub-modules to reduce dependencies. At the current (unreleased) version v.0.15.0 the component hierarchy looks like follows: koswat/ configuration/ # Data structures required for a koswat run. geometries/ io/ settings/ core/ # Generic definitions and functionatilities. geometries/ io/ protocols/ cost_report/ # Summary of costs per dike reinforcement. io/ infrastructure/ multi_location_profile/ profile/ summary/ dike/ # Definition of a koswat dike. characteristic_points/ layers/ material/ profile/ surroundings/ dike_reinforcements/ # Dike calculations to generate possible reinforcements. input_profile/ io/ reinforcement_layers/ reinforcement_profile/ plots/ # Generic functionality for plotting. dike/ geometries/ strategies/ # Different selection methods of all possible dike reinforcements alongside a dike traject. order_strategy And the components interdependencies could be slightly represented as in the following diagram: Image 1. Component diagram Inheritance \u00b6 To facilitate the Open-Closed principle most of our classes have parameterless constructors ( __init__ method). Then, to instantiate objects we often relay on the implementation of builder patterns Protocols \u00b6 In Koswat we make use of Protocols to define the required and essential properties and methods that represent an entity. Although Python does not always enforce these types as other OO languages would do (for instance C#), we try to follow and respect this principle throughought the whole repository. Builder pattern \u00b6 Check for instance this wikipedia article for a more detailed reference. Because most of our classes have dependencies on other classes their initialization would require multiple steps that would become tedious and hard to maintain if they were defined in the default init method. Moreover, this approach would violate the open-closed principle. Therefore, we apply the builder pattern to reduce complexity at the classes, improving maintainability and enabling future developments to create a separate builder shall the design require a different way of instantiating a given class.","title":"Koswat design"},{"location":"reference/koswat_architecture.html#koswat-design","text":"In general, the architecture of this package is based on the following principles: Single responsibility principle, component hierarchy . Open-closed principle, inheritance . Interface segregation principle, protocols .","title":"Koswat design"},{"location":"reference/koswat_architecture.html#component-module-hierarchy","text":"We cluster entities into modules (components) that represent their domain and have minimal dependencies with others components, this way the modules can be accessed when operating Koswat as a sandbox. Within each component we apply the same principle and create sub-modules to reduce dependencies. At the current (unreleased) version v.0.15.0 the component hierarchy looks like follows: koswat/ configuration/ # Data structures required for a koswat run. geometries/ io/ settings/ core/ # Generic definitions and functionatilities. geometries/ io/ protocols/ cost_report/ # Summary of costs per dike reinforcement. io/ infrastructure/ multi_location_profile/ profile/ summary/ dike/ # Definition of a koswat dike. characteristic_points/ layers/ material/ profile/ surroundings/ dike_reinforcements/ # Dike calculations to generate possible reinforcements. input_profile/ io/ reinforcement_layers/ reinforcement_profile/ plots/ # Generic functionality for plotting. dike/ geometries/ strategies/ # Different selection methods of all possible dike reinforcements alongside a dike traject. order_strategy And the components interdependencies could be slightly represented as in the following diagram: Image 1. Component diagram","title":"Component-module hierarchy"},{"location":"reference/koswat_architecture.html#inheritance","text":"To facilitate the Open-Closed principle most of our classes have parameterless constructors ( __init__ method). Then, to instantiate objects we often relay on the implementation of builder patterns","title":"Inheritance"},{"location":"reference/koswat_architecture.html#protocols","text":"In Koswat we make use of Protocols to define the required and essential properties and methods that represent an entity. Although Python does not always enforce these types as other OO languages would do (for instance C#), we try to follow and respect this principle throughought the whole repository.","title":"Protocols"},{"location":"reference/koswat_architecture.html#builder-pattern","text":"Check for instance this wikipedia article for a more detailed reference. Because most of our classes have dependencies on other classes their initialization would require multiple steps that would become tedious and hard to maintain if they were defined in the default init method. Moreover, this approach would violate the open-closed principle. Therefore, we apply the builder pattern to reduce complexity at the classes, improving maintainability and enabling future developments to create a separate builder shall the design require a different way of instantiating a given class.","title":"Builder pattern"},{"location":"reference/koswat_cost_report.html","text":"Cost report \u00b6 A Koswat report is divided in different parts: Summary report : A summary containing all 'location reports'. Location report : Which profile reinforcements can be applied to each location based on their surroundings and reinforcement properties ( MultiLocationProfileCostReport ). Infrastructure report : ( InfrastructureLocationProfileCostReport ) Costs related to applying all calculated reinforcement profiles at the locations where infrastructures are present. Profile report : ( ProfileCostReport ), what are the (material) volume costs associated when applying a given reinforced profile . Layer report : A sub report of the 'profile report' which breaks down the different costs of each one of the layers. This can be seen in Image 1 Volume costs . Image 1. Volume costs Infrastructure report \u00b6 When determining the costs of infrastructures we look mainly at: The reinforcement profile ( ReinforcementProfileProtocol ) zones A and B. The distance between a dike and an infrastructure ( SurroundingsInfrastructure.points , PointSurroundings.surroundings_matrix ). These characteristics are then used to estimate how much surface of the infrastructures will be affected by the reinforced profile and therefore their associated cost. Reinforcement profile zones \u00b6 A reinforced profile can be different from its original state in many ways, however here we are only intestered in two things: The new profile's width from the original waterside crest point. Whether there is a crest's height increase ( dh0 ), By using the old and the reinforced profile's geometries, we can determine what we call zone A and zone B , A + B = {profile's width from waterside crest point} . Zone A represents the width of the dike old profile's crest (highest surface). Zone B the distance between said crest and the end of the dike's reinforcement. Image 1. Reinforcement with dh0 = 0 However, when the crest's height of a ReinforcementProfileProtocol has increased in comparison to its original profile ( ReinforcementProfileProtocol.old_profile , KoswatProfileProtocol ) then we set zone A = 0 and therefore B = {profile's width from waterside crest point} . Image 2. Reinforcement with dh0 = 1 Infrastructure's distances \u00b6 An infrastructure ( SurroundingsInfrastructure ) can be present at different locations ( SurroundingsInfrastructure.points ). Each of these locations ( PointSurroundings ) contains a dictionary ( surroundings_matrix: dict[float, float] ) where the key is the distance between said location and the infrastructure and the values represent the length of the infrastructure found at that distance. For instance, we could have surroundings_matrix = {5: 1.5, 10: 0, 15: 2.5} , which means: - Between 0 and 5 meters from the location we will find 1.5 meters of the infrastructure, - Between 5 and 10 meters from the location we will find 0 meters of the infrastructure, - Between 10 and 15 meters from the location we will find 2.5 meters of the infrastructure. In addition, each infrastructure has a fixed width ( SurroundingsInfrastructure.infrastructure_width ), which can later be used to calculate the total surface of said infrastructure affected by the given profile. So: affected_infra_zone_x = meters_of_infrastructure_in_zone_x * infrastructure_width , where meters_of_infrastructure_in_zone_x are the values calculated from the surroundings_matrix and infrastructure_width is the infrastructure fixed width. Cost calculation \u00b6 After defining the profile's zones A and B we can easily find how much of each infrastructures is affected by checking the surroundings_matrix indices and \"rounding\" up. It is agreed that at the overlapping points between A and B , the affected surface, and therefore costs, will only be computed for zone A ; this is done regardless of the chosen infrastructure costs type ( InfraCostsEnum ). Once the total area is known, we only need to multiply them by their related costs for adding and/or removing infrastructure's material. Example \u00b6 Using as example the previous surroundings_matrix = {5: 1.5, 10: 0, 15: 2.5} we can demostrate this when A = 4 and B = 10 . Estimate zone limits: zone_a goes from 0 to 4, zone_b goes from 4 to 14. Estimate affected points in the surroundings matrix: zone_a affects only up until key 5 , so 1.5 meters of infrastructure. zone_b affects keys 10 and 15 , so 2.5 meters of infrastructure. Note that we do not take 5 as has already been considered for zone_a . Generated files \u00b6 After running a Koswat analysis, several files and directories will be generated. Usually the structure will be as follows: Dike profile section scenarios -> Scenario -> Generated files Dike profile - scenarios directory: Each dike can be run using different scenarios. Scenario: Scenario being applied to the selected dike profile. Dike section: The selected dike section being analyzed. Generated files: A combination of images and a 'csv' matrix result. Images: Visual description of each of the possible reinforcements being applied. summary_costs.csv : A csv file containing all the costs information of the summary. Represents the Summary, Profile and Layer report. summary_locations.csv : A csv file containing per-location a breakdown of available reinforcements and selected reinforcement ( see strategies ). Represents the Location report. /summary_locations directory: contains the following .shp files (and their related binaries): - summary_locations_measures : The same data as present in summary_locations.csv is used to shape the geometry of a dike's traject. We keep as well the type of chosen reinforcement. summary_locations_new : an overlay of summary_locations_measures with the geometry buffered in relation to the new selected reinforcement. summary_locations_old : an overlay of summary_locations_measures with the geometry buffered in relation to the original selected reinforcement. summary_locations_step : an overlay of summary_locations_measures with the geometry buffered in relation to the Ordered Strategy step. summary_infrastructure_costs.csv : A csv file contaning all the infrastructure costs at each location for each of the supported reinforcement profile types. Represents the Infrastructure Report . Example using a summarized view of the output tree directory when running the acceptance test test_main.test_given_valid_input_succeeds : acceptance | koswat.log | +-- results_output | +-- dike_10-1-1-A-1-A | | +-- scenario_scenario1 | | | | Grondmaatregel_profiel.png | | | | Kistdam.png | | | | Kwelscherm.png | | | | summary_costs.csv | | | | summary_locations.csv | | | | summary_infrastructure_costs.csv | | | | Stabiliteitswand.png | | | | Verticale_piping_oplossing.png | | | | | | | +-- summary_locations | | | | summary_locations_measures.cpg | | | | summary_locations_measures.dbf | | | | summary_locations_measures.prj | | | | summary_locations_measures.shp | | | | summary_locations_measures.shx | | | | summary_locations_new.cpg | | | | summary_locations_new.dbf | | | | summary_locations_new.prj | | | | summary_locations_new.shp | | | | summary_locations_new.shx | | | | summary_locations_old.cpg | | | | summary_locations_old.dbf | | | | summary_locations_old.prj | | | | summary_locations_old.shp | | | | summary_locations_step.shx | | | | summary_locations_step.cpg | | | | summary_locations_step.dbf | | | | summary_locations_step.prj | | | | summary_locations_step.shp | | | | summary_locations_step.shx | | | +-- Grondmaatregel_profiel | | | | added_Grondmaatregel_profiel_CLAY.png | | | | added_Grondmaatregel_profiel_GRASS.png | | | | added_Grondmaatregel_profiel_SAND.png | | | | removed_Grondmaatregel_profiel_CLAY.png | | | | removed_Grondmaatregel_profiel_GRASS.png | | | +-- Kistdam | | | | ... | | | | | | +-- Kwelscherm | | | | ... | | | | | | +-- Stabiliteitswand | | | | ... | | | | | | +-- Verticale_piping_oplossing | | | | ... | | | | | +-- scenario_scenario2 | | | ...","title":"Cost report"},{"location":"reference/koswat_cost_report.html#cost-report","text":"A Koswat report is divided in different parts: Summary report : A summary containing all 'location reports'. Location report : Which profile reinforcements can be applied to each location based on their surroundings and reinforcement properties ( MultiLocationProfileCostReport ). Infrastructure report : ( InfrastructureLocationProfileCostReport ) Costs related to applying all calculated reinforcement profiles at the locations where infrastructures are present. Profile report : ( ProfileCostReport ), what are the (material) volume costs associated when applying a given reinforced profile . Layer report : A sub report of the 'profile report' which breaks down the different costs of each one of the layers. This can be seen in Image 1 Volume costs . Image 1. Volume costs","title":"Cost report"},{"location":"reference/koswat_cost_report.html#infrastructure-report","text":"When determining the costs of infrastructures we look mainly at: The reinforcement profile ( ReinforcementProfileProtocol ) zones A and B. The distance between a dike and an infrastructure ( SurroundingsInfrastructure.points , PointSurroundings.surroundings_matrix ). These characteristics are then used to estimate how much surface of the infrastructures will be affected by the reinforced profile and therefore their associated cost.","title":"Infrastructure report"},{"location":"reference/koswat_cost_report.html#reinforcement-profile-zones","text":"A reinforced profile can be different from its original state in many ways, however here we are only intestered in two things: The new profile's width from the original waterside crest point. Whether there is a crest's height increase ( dh0 ), By using the old and the reinforced profile's geometries, we can determine what we call zone A and zone B , A + B = {profile's width from waterside crest point} . Zone A represents the width of the dike old profile's crest (highest surface). Zone B the distance between said crest and the end of the dike's reinforcement. Image 1. Reinforcement with dh0 = 0 However, when the crest's height of a ReinforcementProfileProtocol has increased in comparison to its original profile ( ReinforcementProfileProtocol.old_profile , KoswatProfileProtocol ) then we set zone A = 0 and therefore B = {profile's width from waterside crest point} . Image 2. Reinforcement with dh0 = 1","title":"Reinforcement profile zones"},{"location":"reference/koswat_cost_report.html#infrastructures-distances","text":"An infrastructure ( SurroundingsInfrastructure ) can be present at different locations ( SurroundingsInfrastructure.points ). Each of these locations ( PointSurroundings ) contains a dictionary ( surroundings_matrix: dict[float, float] ) where the key is the distance between said location and the infrastructure and the values represent the length of the infrastructure found at that distance. For instance, we could have surroundings_matrix = {5: 1.5, 10: 0, 15: 2.5} , which means: - Between 0 and 5 meters from the location we will find 1.5 meters of the infrastructure, - Between 5 and 10 meters from the location we will find 0 meters of the infrastructure, - Between 10 and 15 meters from the location we will find 2.5 meters of the infrastructure. In addition, each infrastructure has a fixed width ( SurroundingsInfrastructure.infrastructure_width ), which can later be used to calculate the total surface of said infrastructure affected by the given profile. So: affected_infra_zone_x = meters_of_infrastructure_in_zone_x * infrastructure_width , where meters_of_infrastructure_in_zone_x are the values calculated from the surroundings_matrix and infrastructure_width is the infrastructure fixed width.","title":"Infrastructure's distances"},{"location":"reference/koswat_cost_report.html#cost-calculation","text":"After defining the profile's zones A and B we can easily find how much of each infrastructures is affected by checking the surroundings_matrix indices and \"rounding\" up. It is agreed that at the overlapping points between A and B , the affected surface, and therefore costs, will only be computed for zone A ; this is done regardless of the chosen infrastructure costs type ( InfraCostsEnum ). Once the total area is known, we only need to multiply them by their related costs for adding and/or removing infrastructure's material.","title":"Cost calculation"},{"location":"reference/koswat_cost_report.html#example","text":"Using as example the previous surroundings_matrix = {5: 1.5, 10: 0, 15: 2.5} we can demostrate this when A = 4 and B = 10 . Estimate zone limits: zone_a goes from 0 to 4, zone_b goes from 4 to 14. Estimate affected points in the surroundings matrix: zone_a affects only up until key 5 , so 1.5 meters of infrastructure. zone_b affects keys 10 and 15 , so 2.5 meters of infrastructure. Note that we do not take 5 as has already been considered for zone_a .","title":"Example"},{"location":"reference/koswat_cost_report.html#generated-files","text":"After running a Koswat analysis, several files and directories will be generated. Usually the structure will be as follows: Dike profile section scenarios -> Scenario -> Generated files Dike profile - scenarios directory: Each dike can be run using different scenarios. Scenario: Scenario being applied to the selected dike profile. Dike section: The selected dike section being analyzed. Generated files: A combination of images and a 'csv' matrix result. Images: Visual description of each of the possible reinforcements being applied. summary_costs.csv : A csv file containing all the costs information of the summary. Represents the Summary, Profile and Layer report. summary_locations.csv : A csv file containing per-location a breakdown of available reinforcements and selected reinforcement ( see strategies ). Represents the Location report. /summary_locations directory: contains the following .shp files (and their related binaries): - summary_locations_measures : The same data as present in summary_locations.csv is used to shape the geometry of a dike's traject. We keep as well the type of chosen reinforcement. summary_locations_new : an overlay of summary_locations_measures with the geometry buffered in relation to the new selected reinforcement. summary_locations_old : an overlay of summary_locations_measures with the geometry buffered in relation to the original selected reinforcement. summary_locations_step : an overlay of summary_locations_measures with the geometry buffered in relation to the Ordered Strategy step. summary_infrastructure_costs.csv : A csv file contaning all the infrastructure costs at each location for each of the supported reinforcement profile types. Represents the Infrastructure Report . Example using a summarized view of the output tree directory when running the acceptance test test_main.test_given_valid_input_succeeds : acceptance | koswat.log | +-- results_output | +-- dike_10-1-1-A-1-A | | +-- scenario_scenario1 | | | | Grondmaatregel_profiel.png | | | | Kistdam.png | | | | Kwelscherm.png | | | | summary_costs.csv | | | | summary_locations.csv | | | | summary_infrastructure_costs.csv | | | | Stabiliteitswand.png | | | | Verticale_piping_oplossing.png | | | | | | | +-- summary_locations | | | | summary_locations_measures.cpg | | | | summary_locations_measures.dbf | | | | summary_locations_measures.prj | | | | summary_locations_measures.shp | | | | summary_locations_measures.shx | | | | summary_locations_new.cpg | | | | summary_locations_new.dbf | | | | summary_locations_new.prj | | | | summary_locations_new.shp | | | | summary_locations_new.shx | | | | summary_locations_old.cpg | | | | summary_locations_old.dbf | | | | summary_locations_old.prj | | | | summary_locations_old.shp | | | | summary_locations_step.shx | | | | summary_locations_step.cpg | | | | summary_locations_step.dbf | | | | summary_locations_step.prj | | | | summary_locations_step.shp | | | | summary_locations_step.shx | | | +-- Grondmaatregel_profiel | | | | added_Grondmaatregel_profiel_CLAY.png | | | | added_Grondmaatregel_profiel_GRASS.png | | | | added_Grondmaatregel_profiel_SAND.png | | | | removed_Grondmaatregel_profiel_CLAY.png | | | | removed_Grondmaatregel_profiel_GRASS.png | | | +-- Kistdam | | | | ... | | | | | | +-- Kwelscherm | | | | ... | | | | | | +-- Stabiliteitswand | | | | ... | | | | | | +-- Verticale_piping_oplossing | | | | ... | | | | | +-- scenario_scenario2 | | | ...","title":"Generated files"},{"location":"reference/koswat_dike.html","text":"Dike profile \u00b6 In this section we will describe how a Koswat dike is defined and what its parts are. Koswat properties \u00b6 A koswat dike is represented by an instance of a KoswatProfileProtocol . And its properties represent different aspects of a 'real domain'. With Image 1. Base profile properties as reference, we can see the mapping between said 'real domain' and the koswat properties: input_data : The parts of a dike (written on the image reference), which are directly mapped as an implementation of the KoswatInputProfileProtocol . characteristic_points : 8 points given by the user describing the dike on (x,y) coordinates, the first four represent the waterside ( buitendijks ), the last four the polderside ( binnendijks ). Numbered in the reference picture from 1 to 8. Point 4 is considered to be the reference value (0) with respect to distances of e.g. surroundings and widths of certain parts of the dike. layers_wrapper : The description on how the layers of the dike are built. Further described in Dike layers . location : Geospatial coordinates (x, y) where the dike is situated. profile_width : The difference between the lowest and the highest 'x' coordinates of the profile characteristic points. The distance between characteristic points 1 and 8. This can be broken down into: waterside_width : The distance between characteristics points 1 and 4. polderside_width : The distance between characteristics points 4 and 8. Image 1. Base profile properties The geometry of a dike has certain additional characteristics: - crest ( kruin ): The flat part on top of the dike. - berm ( berm ): The flat part between either point 2 and 3 (waterside) or point 6 an 7 (polderside). - slope ( talud ): The (steepness of the) diagonal parts between points 1 and 4 (waterside) or points 5 and 8 (polderside). - ground level ( maaiveld ): The level of the area to the left of point 1 (waterside) or to the right of point 8 (polderside). Dike layers \u00b6 A dike is composed by three layers: Sand, the core layer. Clay, a coating layer. Grass, a (top) coating layer. These layers are wrapped under a KoswatLayersWrapperProtocol instance. At the same time, each layer is an instance of a KoswatLayerProtocol containing the following properties: material_type : Either Sand, Clay or Grass. upper_points : The surface points of the layer. This property can be used to calculate the surface (m 2 ) of a material. outer_geometry : A polygon representing the material layer and the 'wrapped' polygons. For instance, the Clay outer_geometry will also include the Sand material_geometry . material_geometry : A closed polygon containing only the points representing the layer. Using Image 3. Clay layer highlighted as an example, we can map the previous properties: material_type : Clay, the 'in-between' layer. upper_points : Line with the 'orange' points, without 'closing' the polygon, something like: [(-18, 0), (0, 5.5), (8, 5.5), (21, 0)]. outer_geometry : Closed geometry using the upper points and the 'ground level' ( maaiveld ) points: [(-18, 0), (0, 5.5), (8, 5.5), (21, 0), (-18, 0) ]. material_geometry : Closed geometry using the upper_points from Clay and the upper_points from the layer below (Sand, green points). Should be something like: [(-18, 0), (0, 5.5), (8, 5.5), (21, 0), (19, 0), (8, 4.75), (0, 4.75), (-14, 0), (-18, 0) ] Image 2. Sand layer highlighted Image 3. Clay layer highlighted Image 4. Grass layer highlighted","title":"Dike profile"},{"location":"reference/koswat_dike.html#dike-profile","text":"In this section we will describe how a Koswat dike is defined and what its parts are.","title":"Dike profile"},{"location":"reference/koswat_dike.html#koswat-properties","text":"A koswat dike is represented by an instance of a KoswatProfileProtocol . And its properties represent different aspects of a 'real domain'. With Image 1. Base profile properties as reference, we can see the mapping between said 'real domain' and the koswat properties: input_data : The parts of a dike (written on the image reference), which are directly mapped as an implementation of the KoswatInputProfileProtocol . characteristic_points : 8 points given by the user describing the dike on (x,y) coordinates, the first four represent the waterside ( buitendijks ), the last four the polderside ( binnendijks ). Numbered in the reference picture from 1 to 8. Point 4 is considered to be the reference value (0) with respect to distances of e.g. surroundings and widths of certain parts of the dike. layers_wrapper : The description on how the layers of the dike are built. Further described in Dike layers . location : Geospatial coordinates (x, y) where the dike is situated. profile_width : The difference between the lowest and the highest 'x' coordinates of the profile characteristic points. The distance between characteristic points 1 and 8. This can be broken down into: waterside_width : The distance between characteristics points 1 and 4. polderside_width : The distance between characteristics points 4 and 8. Image 1. Base profile properties The geometry of a dike has certain additional characteristics: - crest ( kruin ): The flat part on top of the dike. - berm ( berm ): The flat part between either point 2 and 3 (waterside) or point 6 an 7 (polderside). - slope ( talud ): The (steepness of the) diagonal parts between points 1 and 4 (waterside) or points 5 and 8 (polderside). - ground level ( maaiveld ): The level of the area to the left of point 1 (waterside) or to the right of point 8 (polderside).","title":"Koswat properties"},{"location":"reference/koswat_dike.html#dike-layers","text":"A dike is composed by three layers: Sand, the core layer. Clay, a coating layer. Grass, a (top) coating layer. These layers are wrapped under a KoswatLayersWrapperProtocol instance. At the same time, each layer is an instance of a KoswatLayerProtocol containing the following properties: material_type : Either Sand, Clay or Grass. upper_points : The surface points of the layer. This property can be used to calculate the surface (m 2 ) of a material. outer_geometry : A polygon representing the material layer and the 'wrapped' polygons. For instance, the Clay outer_geometry will also include the Sand material_geometry . material_geometry : A closed polygon containing only the points representing the layer. Using Image 3. Clay layer highlighted as an example, we can map the previous properties: material_type : Clay, the 'in-between' layer. upper_points : Line with the 'orange' points, without 'closing' the polygon, something like: [(-18, 0), (0, 5.5), (8, 5.5), (21, 0)]. outer_geometry : Closed geometry using the upper points and the 'ground level' ( maaiveld ) points: [(-18, 0), (0, 5.5), (8, 5.5), (21, 0), (-18, 0) ]. material_geometry : Closed geometry using the upper_points from Clay and the upper_points from the layer below (Sand, green points). Should be something like: [(-18, 0), (0, 5.5), (8, 5.5), (21, 0), (19, 0), (8, 4.75), (0, 4.75), (-14, 0), (-18, 0) ] Image 2. Sand layer highlighted Image 3. Clay layer highlighted Image 4. Grass layer highlighted","title":"Dike layers"},{"location":"reference/koswat_main_workflow.html","text":"Main workflow \u00b6 As described in the user manual , the tool can be used either as a sandbox, where the user has responsibility on how to put together an analysis, or as a command line tool. When using the latter unfortunately we will only have one available call, in this chapter we will breakdown this main workflow so that we can better understand the structure of the rest of the package. First of all, let's write the workflow as a pipeline: CLI call -> Import of ini files -> Run scenarios -> Generate reinforcement profiles -> Calculate reinforcement costs -> Apply measure selection strategy -> Calculate total costs -> Export results Image 1. General Workflow CLI Call \u00b6 This step is very straightforward, the command line will run the method run_analysis , which will initiate the KoswatHandler and start an analysis. Import of ini files \u00b6 This step comprehends of several more steps. Usually, for each of the file imports an internal workflow will happen: File -> Import -> File Object Model -> Build -> Data Object Model This step is summarized by the generation of the KoswatRunSettings object. Run scenarios \u00b6 Each KoswatRunScenarioSettings will run a koswat analysis for a given dike section. To do so, a specific KoswatProfileBase will be created based on the conditions from the KoswatScenario and the surroundings of said dike section. Generate reinforcement profiles \u00b6 All reinforcement profiles will be calculated for the scenario KoswatProfileBase profile. Calculate reinforcement costs \u00b6 For this step, we will be creating a cost report For each of the reinforcement profiles we will calculate their associated costs if they were to be applied at all the available traject points where the surroundings allow it. Apply measure selection strategy \u00b6 Based on the available locations and the reinforcements that can be applied to it, a selection strategy finds which construction should be done at each location based on the strategy's criteria. Calculate total costs \u00b6 Once Koswat knows which measure will be applied to each location, and with the previously calculated reinforcement costs , it will estimate the total meters required of each reinforcement and their total cost in euros (\u20ac). Export results \u00b6 Once the costs reports are generate each of the summaries is exported to a *.csv file whilst the reinforcement profiles 'layers' are also exported into different *.png files.","title":"Main workflow"},{"location":"reference/koswat_main_workflow.html#main-workflow","text":"As described in the user manual , the tool can be used either as a sandbox, where the user has responsibility on how to put together an analysis, or as a command line tool. When using the latter unfortunately we will only have one available call, in this chapter we will breakdown this main workflow so that we can better understand the structure of the rest of the package. First of all, let's write the workflow as a pipeline: CLI call -> Import of ini files -> Run scenarios -> Generate reinforcement profiles -> Calculate reinforcement costs -> Apply measure selection strategy -> Calculate total costs -> Export results Image 1. General Workflow","title":"Main workflow"},{"location":"reference/koswat_main_workflow.html#cli-call","text":"This step is very straightforward, the command line will run the method run_analysis , which will initiate the KoswatHandler and start an analysis.","title":"CLI Call"},{"location":"reference/koswat_main_workflow.html#import-of-ini-files","text":"This step comprehends of several more steps. Usually, for each of the file imports an internal workflow will happen: File -> Import -> File Object Model -> Build -> Data Object Model This step is summarized by the generation of the KoswatRunSettings object.","title":"Import of ini files"},{"location":"reference/koswat_main_workflow.html#run-scenarios","text":"Each KoswatRunScenarioSettings will run a koswat analysis for a given dike section. To do so, a specific KoswatProfileBase will be created based on the conditions from the KoswatScenario and the surroundings of said dike section.","title":"Run scenarios"},{"location":"reference/koswat_main_workflow.html#generate-reinforcement-profiles","text":"All reinforcement profiles will be calculated for the scenario KoswatProfileBase profile.","title":"Generate reinforcement profiles"},{"location":"reference/koswat_main_workflow.html#calculate-reinforcement-costs","text":"For this step, we will be creating a cost report For each of the reinforcement profiles we will calculate their associated costs if they were to be applied at all the available traject points where the surroundings allow it.","title":"Calculate reinforcement costs"},{"location":"reference/koswat_main_workflow.html#apply-measure-selection-strategy","text":"Based on the available locations and the reinforcements that can be applied to it, a selection strategy finds which construction should be done at each location based on the strategy's criteria.","title":"Apply measure selection strategy"},{"location":"reference/koswat_main_workflow.html#calculate-total-costs","text":"Once Koswat knows which measure will be applied to each location, and with the previously calculated reinforcement costs , it will estimate the total meters required of each reinforcement and their total cost in euros (\u20ac).","title":"Calculate total costs"},{"location":"reference/koswat_main_workflow.html#export-results","text":"Once the costs reports are generate each of the summaries is exported to a *.csv file whilst the reinforcement profiles 'layers' are also exported into different *.png files.","title":"Export results"},{"location":"reference/koswat_reinforced_profile.html","text":"Reinforcement profile \u00b6 In koswat we consider a reinforcement profile the result of applying one of the multiple possible reinforcement calculations on an instance of a KoswatProfileBase ( Koswat dike ). This chapter covers the description of a reinforcement profile and its parts. Properties \u00b6 A reinforcement profile implements the ReinforcementProfileProtocol , which is a specialization of the KoswatProfileProtocol with some differences: input_data : Similar to the base profile input_data but instead implements the ReinforcementInputProfileProtocol , a specialization of the ( KoswatInputProfileProtocol ) which depends on the type of reinforcement being applied. old_profile : New property which contains the koswat profile from which the calculation was based on. Possible reinforcements. \u00b6 We have two main different sort of reinfocements which contain also subtypes for said reinforcements: Outside slope reinforcement : Cofferdam ( kistdam ), based on the OutsideSlopeReinforcementProfile . With this reinforcement the outside slope ( buiten talud ) of the dike is impacted. Standard reinforcement : Piping wall ( kwelscherm ), soil ( grondmaatregel profiel ), stability wall ( stabiliteitswand ), vertical piping solution ( verticale piping oplossing ). The previous being based on the StandardReinforcementProfile . A piping wall can be implemented by a cb wall ( cement-bentoniet wand ) and an unanchored sheet pile ( onverankerde damwand ). A stability wall can be implemented by a diaphragm wall ( diepwand ) and an anchored sheet pile ( verankerde damwand ). In addition, the above mentioned reinforcements can also implement their own ReinforcementInputProfileProtocol , which are after all extensions of the KoswatInputProfileBase with extra properties.","title":"Reinforcement profile"},{"location":"reference/koswat_reinforced_profile.html#reinforcement-profile","text":"In koswat we consider a reinforcement profile the result of applying one of the multiple possible reinforcement calculations on an instance of a KoswatProfileBase ( Koswat dike ). This chapter covers the description of a reinforcement profile and its parts.","title":"Reinforcement profile"},{"location":"reference/koswat_reinforced_profile.html#properties","text":"A reinforcement profile implements the ReinforcementProfileProtocol , which is a specialization of the KoswatProfileProtocol with some differences: input_data : Similar to the base profile input_data but instead implements the ReinforcementInputProfileProtocol , a specialization of the ( KoswatInputProfileProtocol ) which depends on the type of reinforcement being applied. old_profile : New property which contains the koswat profile from which the calculation was based on.","title":"Properties"},{"location":"reference/koswat_reinforced_profile.html#possible-reinforcements","text":"We have two main different sort of reinfocements which contain also subtypes for said reinforcements: Outside slope reinforcement : Cofferdam ( kistdam ), based on the OutsideSlopeReinforcementProfile . With this reinforcement the outside slope ( buiten talud ) of the dike is impacted. Standard reinforcement : Piping wall ( kwelscherm ), soil ( grondmaatregel profiel ), stability wall ( stabiliteitswand ), vertical piping solution ( verticale piping oplossing ). The previous being based on the StandardReinforcementProfile . A piping wall can be implemented by a cb wall ( cement-bentoniet wand ) and an unanchored sheet pile ( onverankerde damwand ). A stability wall can be implemented by a diaphragm wall ( diepwand ) and an anchored sheet pile ( verankerde damwand ). In addition, the above mentioned reinforcements can also implement their own ReinforcementInputProfileProtocol , which are after all extensions of the KoswatInputProfileBase with extra properties.","title":"Possible reinforcements."},{"location":"reference/koswat_strategies.html","text":"Strategies \u00b6 Koswat can determine which is the \"best\" reinforcement type for a dike traject based on different selection criteria that we name \"strategies\" ( StrategyProtocol ). A strategy requires a strategy input ( StrategyInput ), this input contains information over which reinforcement types are available at each location as well as what's the minimal buffer ( reinforcement_min_buffer ) and minimal length ( reinforcement_min_length ) for each reinforcement type. By default a strategy is applied as follows: For each point (meter) in the traject, determine which reinforcements can be applied to it. Choose one of the available reinforcements based on the chosen strategy . When no reinforcement is available the most restrictive will be chosen ( CofferDam ). Apply a buffer ( reinforcement_min_buffer ) for each one of the reinforcements. Check if the minimal distance between constructions is met ( reinforcement_min_length ), otherwise change it into one of the reinforcements next to it. Repeat 4 until all reinforcements have enough distance between themselves. Find based on the strategy for infrastructure derived costs , mapped locations ( list[StrategyLocationReinforcement] ) whose reinforcement can be increased into a most restrictive one with total lower costs. Return list of mapped locations ( list[StrategyLocationReinforcement] ). Available strategies \u00b6 Currently the following strategies are implemented: Order based Infrastructure priority , by default the strategy to run during a Koswat analysis. Order based \u00b6 This strategy is the first and default of all defined strategies. Its criteria is based on a pre-defined 'order' of each reinforcement. In steps, it can be seen as: Pre-selection of a location's available reinforcement based on said order, when a location does not have any \"available\" reinforcement, then the last reinforcement's order will be pre-selected. Grouping of all locations by their pre-selected reinforcement. Buffering to each of the groupings. Clustering to the resulting groupings from the previous step. Reinforcement order \u00b6 The reinforcements are ordered based on increasing cost (including surtax) and decreasing width. Reinforcements that are more expensive but are wider or have equal width are skipped (order -1 ). The CofferDamReinforcementProfile will never be skipped and is always the last reinforcement that is applied in case no other reinforcement fits the surroundings. Reinforcement type Profile width Cost with surtax Index SoilReinforcementProfile 10 100 0 VPSReinforcementProfile 20 200 -1 PipingWallReinforcementProfile 10 300 -1 StabilityWallReinforcementProfile 5 400 1 CofferDamReinforcementProfile 0 500 2 Reinforcement grouping \u00b6 We create reinforcement-location \"grouping\" for the whole traject. A grouping represents a reinforcement type that is \"selected\" for a series of continuous locations. This means locations that are next to each other sharing the same measure type ( Type[ReinforcementProfileProtocol] ). Grouping example \u00b6 Simplified representation for a traject with 10 locations. This example is also tested in the tests.strategies.order_strategy.py test file. { \"SoilReinforcementProfile\" : [ \"Location_000\" , \"Location_001\" , \"Location_002\" , ], \"StabilityWallReinforcementProfile\" : [ \"Location_003\" , \"Location_004\" , ], \"SoilReinforcementProfile\" : [ \"Location_005\" , \"Location_006\" , \"Location_007\" , ], \"CofferDamReinforcementProfile\" : [ \"Location_008\" , \"Location_009\" , ], } Reinforcement buffering \u00b6 Given a reinforcement grouping , we will create a dictionary of masks of size NM where N (the keys) is the number of available reinforcement types ( Type[ReinforcementProfileProtocol] ) and M the number of available locations. Note : Masks' values are the position of a reinforcement type in the reinforcement's order list . So a location with CofferDamReinforcementProfile will have a 4 at the mask's position, whilst a SoilReinforcementProfile will have a 0 instead (remember in Python indexing starts with 0). Steps breakdown : Initialize the dictionary masks with all values to -1. Iterate over the groupings list, and for each entry: Select the mask to update using the grouping's reinforcement type (cluster's key). Update the indices representing the grouping's locations (grouping's values) with the matching value for this grouping's key (see previous note ). Add a buffer ( StrategyInput.reinforcement_min_buffer ) by updating the adjacent's positions of this grouping with the same values as in step 1. Merge all masks into a 1-dimensional array where the cell's value is the maximum between the available masks. This is done to prevent that a buffer of a \"stronger\" demanding reinforcement such as CofferDamReinforcementProfile is replaced by a \"weaker\" one. Update the locations with their new associated reinforcement. The resulting mask contains the index of the reinforcement to be applied in the reinforcement's order . Buffering example \u00b6 One simplified example, based on the grouping example , and using a buffer value of \"1\". This example is also tested in the tests.strategies.order_strategy_buffering.py test file. 1. I n i t ialize t he masks based o n t he provided clus ters : { \"SoilReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"VPSReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"PipingWallReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"StabilityWallReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"CofferDamReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], } 2. I terate over t he clus ters a n d upda te t he masks' values : { \"SoilReinforcementProfile\" : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , -1 ], \"VPSReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"PipingWallReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"StabilityWallReinforcementProfile\" : [ -1 , -1 , 3 , 3 , 3 , 3 , -1 , -1 , -1 , -1 ], \"CofferDamReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , 4 , 4 , 4 ], } 3. Merge all masks a n d selec t t heir maximum value : [ 0 , 0 , 3 , 3 , 3 , 3 , 0 , 4 , 4 , 4 ] 4. Upda te t he clus ter 's loca t io ns : { \"SoilReinforcementProfile\" : [ \"Location_000\" , \"Location_001\" , ], \"StabilityWallReinforcementProfile\" : [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , ], \"SoilReinforcementProfile\" : [ \"Location_006\" , ], \"CofferDamReinforcementProfile\" : [ \"Location_007\" , \"Location_008\" , \"Location_009\" , ], } Reinforcement clustering \u00b6 Given a reinforcement grouping , ideally done after applying buffering , we will now proceed to change the pre-selected reinforcement of all those groupings that contain less locations than required by the describing property. We do this by updating their type with the one of a \"stronger\" adjacent grouping, on this section called \"clusters\". These clusters are internally represented by the class OrderCluster . The strategy here is to detect non-compliant reinforcement-location clusters and replace their selected reinforcement type with the \"least strong\" of its adjacent clusters. We do this iteratively, so we first target the lowest type of reinforcements ( SoilReinforcementProfile ) and we move up until the first to the last (the last one cannot be further strengthened). Conditions : We define a non-compliant cluster as a cluster that does not contain as many locations as defined by the minimal length requirement ( reinforcement_min_length ). We also define a non-compliant exception when a cluster does not meet said requirement but the adjacent clusters are of a lower reinforcement type. Therefore retaining their initial reinforcement type. The first and last clusters, are always considered compliant . Therefore they retain their initial reinforcement type. Clusters whose reinforcement type is placed the last in the strategy's order , are skipped and always considered compliant , as they cannot be further strengthened. Steps breakdown : Generate a list of all available unmerged clusters. For each reinforcement type target-reinforcement , in the strategy order: Get the current non-compliant clusters For each non-compliant target-reinforcement cluster : Check if its indeed not compliant. Otherwise move to the next cluster. Get a stronger cluster among the neighbors. Selects the neighbor with the \"weakest\", yet greater than the actual, reinforcement type value. If both neighbors are \"weaker\" than the current reinforcement type, then it is considered an \"exception\" as it cannot be further strengthened. We therefore move to the next non-compliant cluster. Move the current cluster's locations to the stronger reinforcement cluster. Remove the cluster from the \"available clusters\" list as it is integrated in step 2.2.3. Clustering example \u00b6 One simplified example, based on the buffering example , and using a minimal distance of \"5\". This example is also tested in the tests.strategies.order_strategy_clustering.py test file. 1. Lis t o f u n merged clus ters : { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" ,] ) , ( 0 , [ \"Location_006\" ,] ) , ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) } 2. I terate over each rei nf orceme nt t ype : 2.1. Targe t is \"SoilReinforcementProfile\" (idx= 0 ) , n o n - complia nt clus ters { ( 0 , [ \"Location_006\" ,] ) } 2.1.1. Le n g t h = 1. 2.1.2. Ge t a s tr o n ger ne ighbor , - Le ft - ne ighbor rei nf orceme nt t ype = 3 , - Righ t - ne ighbor rei nf orceme nt t ype = 4 , - Le ft - ne ighbor is selec te d. 2.1.3. Move loca t io ns t o s tr o n ger ne ighbor. { ( 2 , [ \"Location_002\" , ... , \"Location_006\" ,] ) , ( 0 , [ \"Location_006\" ,] ) , } 2.1.4. Remove t he curre nt clus ter fr om t he available lis t . 2.2. Targe t is \"PipingWallReinforcementProfile\" (idx= 2 ) , - All clus ters are complia nt a t t his poi nt . 2.3. Targe t is \"StabilityWallReinforcementProfile\" (idx= 3 ) , - All clus ters are complia nt a t t his poi nt . 2.4. \"CofferDamReinforcementProfile\" (idx= 4 ) - Las t rei nf orceme nt pro f ile t ype , t here f ore t he s tr o n ges t . Resul t i n g clus ter : { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) , ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , } Infrastructure priority \u00b6 DEFAULT STRATEGY This strategy checks whether the clusters resulting from the order based strategy can change their selected reinforcement to one with cheaper costs. These costs are extracted from the cost report and relate to the reinforcement profile costs (dike's materials for the required space) and the possible infrastructure costs . In steps, this strategy can be broke down as: Steps breakdown : Assignment of order based clusters , Cluster options evaluation, Common available measures cost calculation, Cheapest option selection, Update reinforcement selection with selected option. Cluster options \u00b6 For an optimal assignment of a new reinforcement profile, we make use of \"subclusters\". These subclusters are contiguous subsets from an order based cluster and have the minimal required length ( StrategyInput.reinforcement_min_cluster ). The logic for this section can be found in InfraPriorityStrategy.generate_subcluster_options . For each of original the clusters, multiple combinations of subclusters are possible. We refer to them as \" cluster option \" ( InfraClusterOption ) . We can already discard creating subclusters when the size of the original cluster is less than twice the required minimal length. So for a minimal length of 2 locations, you require a cluster of at least 4 locations to generate subclusters. Conditions : We only create subclusters when the cluster's original size is, at least, twice the required minimal cluster's length. We estimate the cluster's minimal length to be at least twice the size of the buffer so: min_cluster_length = (2 * reinforcement_min_buffer) + 1 . We create subclusters based on the immediate results of the order based strategy . We do not try to combine or create new clusters based on a \"greedier\" strategy. Cluster option example \u00b6 For example, given the results of the clustering example we can calculate the options for the clusters for a required minimal length of 2 : List of clusters: { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) , ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , } Options for cluster {(0, [\"Location_000\",\"Location_001\",])} - Valid op t io ns : ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) Options for cluster {(3, [\"Location_002\",\"Location_003\", \"Location_004\",\"Location_005\", \"Location_006\",])} - Valid : - {[ \"Location_002\" , \"Location_003\" ], [ \"Location_004\" , \"Location_005\" , \"Location_006\" ]}, - {[ \"Location_002\" , \"Location_003\" , \"Location_004\" ], [ \"Location_005\" , \"Location_006\" ]} - I n valid : - f irs t subclus ter 's size is less t ha n required : {[ \"Location_002\" ], [ \"Location_003\" , \"Location_004\" ], [ \"Location_005\" , \"Location_006\" ]} - las t subclus ter 's size is less t ha n required : {[ \"Location_002\" , \"Location_003\" ], [ \"Location_004\" , \"Location_005\" ], [ \"Location_006\" ]}, - seco n d subclus ter 's size is less t ha n required : {[ \"Location_002\" , \"Location_003\" ], [ \"Location_004\" ], [ \"Location_005\" , \"Location_006\" ]}, - a n d so o n ... Options for cluster {(4, [\"Location_007\",\"Location_008\",\"Location_009\",]),} - Valid : - {[ \"Location_007\" , \"Location_008\" , \"Location_009\" ,]} - I n valid : - f irs t subclus ter 's size is less t ha n required : {[ \"Location_007\" ], [ \"Location_008\" , \"Location_009\" ]} - las t subclus ter 's size is less t ha n required : {[ \"Location_007\" , \"Location_008\" ], [ \"Location_009\" ]} - a n d so o n ... Cluster common available measures' cost \u00b6 Once we have calculated a cluster's option we can determine whether this cluster should be consider as a valid one. This estimation is based on the cheapest reinforcement's cost (including surtax), and to get this value we first need to know which reinforcements are available at all the locations of this option. We will store this value in the InfraClusterOption.cluster_costs . In the current implementation, these costs are added to the InfraClusterOption together with the cluster's data ( list[InfraCluster] ). Conditions : A \"viable\" cluster option must be cheaper than the order's cluster and has the cluster's minimal length. We consider \"minimal costs\" or \"lower costs\" as the lowest cost of applying a certain reinforcement type to a given subcluster. Common available measures' cost example \u00b6 Following the options example we can estimate some fictional costs based on the following tables (if a type / location is not mentioned, then assume its cost is zero ( 0 )): Index Reinforcement type base cost incl. surtax 0 Soil reinforcement 42 1 Vertical Piping Solution 420 2 Piping Wall 4.200 3 Stability Wall 42.000 4 Cofferdam 420.000 Location Reinforcement indices Infrastructure cost incl. surtax Location_000 0, 1 4.200.000 Location_005 0, 1, 2, 3 4.200.000 We already know that only the second cluster can generate subclusters, therefore different valid options, so we will use said subcluster's options for the example. 1. De ter mi ne curre nt cos t : - { 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ]} - Base cos ts = 5 * 42.000 = 210.000 - I nfra cos ts = ( 1 ) * 4.200.000 = 4.200.000 - To tal cos ts = 4.410.000 2. Calcula te cos ts f or f irs t op t io n : - { ( 3 , [ \"Location_002\" , \"Location_003\" ], [ \"Location_004\" , \"Location_005\" , \"Location_006\" ] ) }, 1. Firs t subclus ter 's commo n measures : - S ta bili t y Wall (curre nt ) : - Base cos ts = 2 * 42.000 = 84.000 - I nfra cos ts = 0 - To tal cos ts = 42.000 - Co ffer dam : - Base cos ts = 2 * 420.000 = 840.000 - I nfra cos ts = 0 - To tal cos ts = 840.000 - The curre nt rei nf oceme nt is cheaper 2. Seco n d subclus ter 's commo n measures : - S ta bili t y Wall (curre nt ) : - Base cos ts = 3 * 42.000 = 126.000 - I nfra cos ts = ( 1 ) * 4.200.000 = 4.200.000 - To tal cos ts = 4.326.000 - Co ffer dam : - Base cos ts = 3 * 420.000 = 1.260.000 - I nfra cos ts = 0 - To tal cos ts = 1.260.000 - Co ffer dam will be cheaper. 3. Subclus ter 's bes t op t io n is cheaper t ha n curre nt : - { ( 3 , [ \"Location_002\" , \"Location_003\" ] ) , ( 4 , [ \"Location_004\" , \"Location_005\" , \"Location_006\" ] ) } - To tal cos t = 42.000 + 1.260.000 = 1.302.000 - Selec te d as op t io n . 3. Calcula te cos ts f or seco n d op t io n : - { 3 , ( [ \"Location_002\" , \"Location_003\" , \"Location_004\" ], [ \"Location_005\" , \"Location_006\" ] ) } 1. Firs t sublus ter 's commo n measures - S ta bili t y Wall (curre nt ) : - Base cos ts = 3 * 42.000 = 126.000 - I nfra cos ts = 0 - To tal cos ts = 126.000 - Co ffer dam : - Base cos ts = 3 * 420.000 = 1.260.000 - I nfra cos ts = 0 - To tal cos ts = 1.260.000 - The curre nt rei nf oceme nt is cheaper 2. Seco n d sublus ter 's commo n measures - S ta bili t y Wall (curre nt ) : - Base cos ts = 2 * 42.000 = 84.000 - I nfra cos ts = 0 - To tal cos ts = 84.000 - Co ffer dam : - Base cos ts = 2 * 420.000 = 840.000 - I nfra cos ts = 0 - To tal cos ts = 840.000 - Co ffer dam is cheaper 3. Subclus ter 's bes t op t io n is cheaper t ha n selec t io n : - { ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" ] ) , ( 4 , [ \"Location_005\" , \"Location_006\" ] ) } - To tal cos t = 126.000 + 840.000 = 966.000 - Selec te d as op t io n . 4. Upda te loca t io ns ' selec te d rei nf orceme nt : { ( 2 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" ,] ) , ( 4 , [ \"Location_005\" , \"Location_006\" , \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , } In this example we can therefore demonstrate the cost reduction. The last column represents the difference (positive means saved money): O.S. = Order strategy I.S. = Infrastructure priority strategy Location (O.S.) reinforcement (O.S.) cost (I.S.) reinforcement (I.S.) cost Difference Total ---- 6.090.084 ---- 2.226.840 +3.863.244 Location_000 Soil reinforcement 4.200.042 Piping Wall 420 +4.199.622 Location_001 Soil reinforcement 42 Piping Wall 420 -378 Location_002 Stability Wall 42.000 Stability Wall 42.000 0 Location_003 Stability Wall 42.000 Stability Wall 42.000 0 Location_004 Stability Wall 42.000 Stability Wall 42.000 0 Location_005 Stability Wall 462.000 Cofferdam 420.000 +42000 Location_006 Stability Wall 42.000 Cofferdam 420.000 -378000 Location_007 Cofferdam 420.000 Cofferdam 420.000 0 Location_008 Cofferdam 420.000 Cofferdam 420.000 0 Location_009 Cofferdam 420.000 Cofferdam 420.000 0 Infrastructure priority (old approach) example \u00b6 Important! This example is based on the first approach of this strategy and its steps might differ from the current solution. We left this example as it can help understanding the basic concepts of the strategy. We will start by defining some unrealistic costs per reinforcement type for all locations* such as. For a more realistic scenario check the subclustering example : Index Reinforcement type base cost infra cost total cost 0 Soil reinforcement 42 420.000 420.042 1 Vertical Piping Solution 420 420.000 420.420 2 Piping Wall 4200 0 4200 3 Stability Wall 42.000 420.000 462.000 4 Cofferdam 420.000 0 420.000 Important! For example purposes we are applying the same infrastructure costs to all the locations. |However, in a real case these costs would vary per location (and per reinforcement type). So we can determine the cluster's reinforcement costs as (total cost) * N locations Based on this data Piping Wall will be chosen unless any of the points in the cluster cannot apply it due to obstacles or other constraints, in which case it would end up settling for a Cofferdam reinforcement. Let's see now the strategy steps using the results from the clustering example : 1. Lis t o f clus ters : { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) , ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , } 2. I terate over each clus ter : 2.1. Firs t clus ter is : { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) } 2.1.1. Ge t t he curre nt cos t o f usi n g t his clus ter . - To tal cos ts * N loca t io ns = `( 420042 ) * 2 = 840084 ` 2.1.2. Ge t cheaper commo n available measures : - Soil Rei nf orceme nt , (idx= 0 ) , - [ Discard ] Curre nt selec t io n . - Ver t ical Pipi n g Solu t io n , (idx= 1 ) , - Cos ts = `( 420.420 ) * 2 = 840.840 ` - [ Discard ] Cos ts are higher t ha n i n i t ial s tate . - Pipi n g Wall , (idx= 2 ) , - Cos ts = `( 4.200 + 0 ) * 2 = 8.400 ` - [ Keep ] Cos ts are cheaper t ha n t he i n i t ial s tate . - S ta bili t y Wall , (idx= 3 ) , - Cos ts = `( 462.000 ) * 2 = 924.000 ` - [ Discard ] Cos ts are higher t ha n i n i t ial s tate . - Co ffer dam , (idx= 3 ) , - Cos ts = `( 420.000 ) * 2 = 840.000 ` - [ Keep ] Cos ts are cheaper t ha n t he i n i t ial s tate , keep. 2.1.3. Se t t he cheapes t commo n available measure per clus ter : - Pipi n g wall < Co ffer dam < Soil rei nf orceme nt (curre nt ) - Pipi n g wall is t he ne w rei nf orceme nt f or t his clus ter . - Resul t : { ( 2 , [ \"Location_000\" , \"Location_001\" ,] ) } 2.2. Seco n d clus ter is : { ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) } 2.3.1. Ge t t he curre nt cos t o f usi n g t his clus ter . - To tal cos ts * N loca t io ns = `( 462.000 ) * 5 = 2.310.000 ` 2.3.2. Ge t cheaper commo n available measures. - Soil Rei nf orceme nt , (idx= 0 ) , - [ Discard ] No t prese nt a t \"Location_003\" , \"Location_004\" . - Ver t ical Pipi n g Solu t io n , (idx= 1 ) , - [ Discard ] No t prese nt a t \"Location_003\" , \"Location_004\" . - Pipi n g Wall , (idx= 2 ) , - [ Discard ] No t prese nt a t \"Location_003\" , \"Location_004\" . - S ta bili t y Wall , (idx= 3 ) , - [ Discard ] Curre nt selec t io n . - Co ffer dam , (idx= 3 ) , - Cos ts = `( 420.000 ) * 5 = 2.100.000 ` - [ Keep ] Cos ts are cheaper t ha n t he i n i t ial s tate . 2.3.3. Se t t he cheapes t commo n available measure per clus ter : - Co ffer dam < S ta bili t y wall - Co ffer dam is t he ne w rei nf orceme nt f or t his clus ter . - Resul t : { ( 4 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) } 2.3. Third clus ter is : { ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) }} 2.3.1. Ge t t he curre nt cos t o f usi n g t his clus ter . - To tal cos ts * N loca t io ns = `( 420.000 ) * 3 = 1.260.000 ` 2.3.2. Ge t cheaper commo n available measures. - Co ffer dam , (idx= 4 ) , - Curre nt selec t io n . 2.3.3. Se t t he cheapes t commo n available measure per clus ter : - O nl y co ffer dam available , - No furt her ac t io n . - Resul t : { ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) } 2.4. Resul t i n g clus ters : { ( 2 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 4 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" , \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , } With this, we went from: Initial costs: (420.042) * 2 + (462.000) * 5 + (420.000) * 3 = 4.410.084 , to Final costs: (4.200) * 2 + (420.000) * 8 = 3.368.400 Which would amount to a total save of 1.041.684\u20ac","title":"Strategies"},{"location":"reference/koswat_strategies.html#strategies","text":"Koswat can determine which is the \"best\" reinforcement type for a dike traject based on different selection criteria that we name \"strategies\" ( StrategyProtocol ). A strategy requires a strategy input ( StrategyInput ), this input contains information over which reinforcement types are available at each location as well as what's the minimal buffer ( reinforcement_min_buffer ) and minimal length ( reinforcement_min_length ) for each reinforcement type. By default a strategy is applied as follows: For each point (meter) in the traject, determine which reinforcements can be applied to it. Choose one of the available reinforcements based on the chosen strategy . When no reinforcement is available the most restrictive will be chosen ( CofferDam ). Apply a buffer ( reinforcement_min_buffer ) for each one of the reinforcements. Check if the minimal distance between constructions is met ( reinforcement_min_length ), otherwise change it into one of the reinforcements next to it. Repeat 4 until all reinforcements have enough distance between themselves. Find based on the strategy for infrastructure derived costs , mapped locations ( list[StrategyLocationReinforcement] ) whose reinforcement can be increased into a most restrictive one with total lower costs. Return list of mapped locations ( list[StrategyLocationReinforcement] ).","title":"Strategies"},{"location":"reference/koswat_strategies.html#available-strategies","text":"Currently the following strategies are implemented: Order based Infrastructure priority , by default the strategy to run during a Koswat analysis.","title":"Available strategies"},{"location":"reference/koswat_strategies.html#order-based","text":"This strategy is the first and default of all defined strategies. Its criteria is based on a pre-defined 'order' of each reinforcement. In steps, it can be seen as: Pre-selection of a location's available reinforcement based on said order, when a location does not have any \"available\" reinforcement, then the last reinforcement's order will be pre-selected. Grouping of all locations by their pre-selected reinforcement. Buffering to each of the groupings. Clustering to the resulting groupings from the previous step.","title":"Order based"},{"location":"reference/koswat_strategies.html#reinforcement-order","text":"The reinforcements are ordered based on increasing cost (including surtax) and decreasing width. Reinforcements that are more expensive but are wider or have equal width are skipped (order -1 ). The CofferDamReinforcementProfile will never be skipped and is always the last reinforcement that is applied in case no other reinforcement fits the surroundings. Reinforcement type Profile width Cost with surtax Index SoilReinforcementProfile 10 100 0 VPSReinforcementProfile 20 200 -1 PipingWallReinforcementProfile 10 300 -1 StabilityWallReinforcementProfile 5 400 1 CofferDamReinforcementProfile 0 500 2","title":"Reinforcement order"},{"location":"reference/koswat_strategies.html#reinforcement-grouping","text":"We create reinforcement-location \"grouping\" for the whole traject. A grouping represents a reinforcement type that is \"selected\" for a series of continuous locations. This means locations that are next to each other sharing the same measure type ( Type[ReinforcementProfileProtocol] ).","title":"Reinforcement grouping"},{"location":"reference/koswat_strategies.html#grouping-example","text":"Simplified representation for a traject with 10 locations. This example is also tested in the tests.strategies.order_strategy.py test file. { \"SoilReinforcementProfile\" : [ \"Location_000\" , \"Location_001\" , \"Location_002\" , ], \"StabilityWallReinforcementProfile\" : [ \"Location_003\" , \"Location_004\" , ], \"SoilReinforcementProfile\" : [ \"Location_005\" , \"Location_006\" , \"Location_007\" , ], \"CofferDamReinforcementProfile\" : [ \"Location_008\" , \"Location_009\" , ], }","title":"Grouping example"},{"location":"reference/koswat_strategies.html#reinforcement-buffering","text":"Given a reinforcement grouping , we will create a dictionary of masks of size NM where N (the keys) is the number of available reinforcement types ( Type[ReinforcementProfileProtocol] ) and M the number of available locations. Note : Masks' values are the position of a reinforcement type in the reinforcement's order list . So a location with CofferDamReinforcementProfile will have a 4 at the mask's position, whilst a SoilReinforcementProfile will have a 0 instead (remember in Python indexing starts with 0). Steps breakdown : Initialize the dictionary masks with all values to -1. Iterate over the groupings list, and for each entry: Select the mask to update using the grouping's reinforcement type (cluster's key). Update the indices representing the grouping's locations (grouping's values) with the matching value for this grouping's key (see previous note ). Add a buffer ( StrategyInput.reinforcement_min_buffer ) by updating the adjacent's positions of this grouping with the same values as in step 1. Merge all masks into a 1-dimensional array where the cell's value is the maximum between the available masks. This is done to prevent that a buffer of a \"stronger\" demanding reinforcement such as CofferDamReinforcementProfile is replaced by a \"weaker\" one. Update the locations with their new associated reinforcement. The resulting mask contains the index of the reinforcement to be applied in the reinforcement's order .","title":"Reinforcement buffering"},{"location":"reference/koswat_strategies.html#buffering-example","text":"One simplified example, based on the grouping example , and using a buffer value of \"1\". This example is also tested in the tests.strategies.order_strategy_buffering.py test file. 1. I n i t ialize t he masks based o n t he provided clus ters : { \"SoilReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"VPSReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"PipingWallReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"StabilityWallReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"CofferDamReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], } 2. I terate over t he clus ters a n d upda te t he masks' values : { \"SoilReinforcementProfile\" : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , -1 ], \"VPSReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"PipingWallReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ], \"StabilityWallReinforcementProfile\" : [ -1 , -1 , 3 , 3 , 3 , 3 , -1 , -1 , -1 , -1 ], \"CofferDamReinforcementProfile\" : [ -1 , -1 , -1 , -1 , -1 , -1 , -1 , 4 , 4 , 4 ], } 3. Merge all masks a n d selec t t heir maximum value : [ 0 , 0 , 3 , 3 , 3 , 3 , 0 , 4 , 4 , 4 ] 4. Upda te t he clus ter 's loca t io ns : { \"SoilReinforcementProfile\" : [ \"Location_000\" , \"Location_001\" , ], \"StabilityWallReinforcementProfile\" : [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , ], \"SoilReinforcementProfile\" : [ \"Location_006\" , ], \"CofferDamReinforcementProfile\" : [ \"Location_007\" , \"Location_008\" , \"Location_009\" , ], }","title":"Buffering example"},{"location":"reference/koswat_strategies.html#reinforcement-clustering","text":"Given a reinforcement grouping , ideally done after applying buffering , we will now proceed to change the pre-selected reinforcement of all those groupings that contain less locations than required by the describing property. We do this by updating their type with the one of a \"stronger\" adjacent grouping, on this section called \"clusters\". These clusters are internally represented by the class OrderCluster . The strategy here is to detect non-compliant reinforcement-location clusters and replace their selected reinforcement type with the \"least strong\" of its adjacent clusters. We do this iteratively, so we first target the lowest type of reinforcements ( SoilReinforcementProfile ) and we move up until the first to the last (the last one cannot be further strengthened). Conditions : We define a non-compliant cluster as a cluster that does not contain as many locations as defined by the minimal length requirement ( reinforcement_min_length ). We also define a non-compliant exception when a cluster does not meet said requirement but the adjacent clusters are of a lower reinforcement type. Therefore retaining their initial reinforcement type. The first and last clusters, are always considered compliant . Therefore they retain their initial reinforcement type. Clusters whose reinforcement type is placed the last in the strategy's order , are skipped and always considered compliant , as they cannot be further strengthened. Steps breakdown : Generate a list of all available unmerged clusters. For each reinforcement type target-reinforcement , in the strategy order: Get the current non-compliant clusters For each non-compliant target-reinforcement cluster : Check if its indeed not compliant. Otherwise move to the next cluster. Get a stronger cluster among the neighbors. Selects the neighbor with the \"weakest\", yet greater than the actual, reinforcement type value. If both neighbors are \"weaker\" than the current reinforcement type, then it is considered an \"exception\" as it cannot be further strengthened. We therefore move to the next non-compliant cluster. Move the current cluster's locations to the stronger reinforcement cluster. Remove the cluster from the \"available clusters\" list as it is integrated in step 2.2.3.","title":"Reinforcement clustering"},{"location":"reference/koswat_strategies.html#clustering-example","text":"One simplified example, based on the buffering example , and using a minimal distance of \"5\". This example is also tested in the tests.strategies.order_strategy_clustering.py test file. 1. Lis t o f u n merged clus ters : { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" ,] ) , ( 0 , [ \"Location_006\" ,] ) , ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) } 2. I terate over each rei nf orceme nt t ype : 2.1. Targe t is \"SoilReinforcementProfile\" (idx= 0 ) , n o n - complia nt clus ters { ( 0 , [ \"Location_006\" ,] ) } 2.1.1. Le n g t h = 1. 2.1.2. Ge t a s tr o n ger ne ighbor , - Le ft - ne ighbor rei nf orceme nt t ype = 3 , - Righ t - ne ighbor rei nf orceme nt t ype = 4 , - Le ft - ne ighbor is selec te d. 2.1.3. Move loca t io ns t o s tr o n ger ne ighbor. { ( 2 , [ \"Location_002\" , ... , \"Location_006\" ,] ) , ( 0 , [ \"Location_006\" ,] ) , } 2.1.4. Remove t he curre nt clus ter fr om t he available lis t . 2.2. Targe t is \"PipingWallReinforcementProfile\" (idx= 2 ) , - All clus ters are complia nt a t t his poi nt . 2.3. Targe t is \"StabilityWallReinforcementProfile\" (idx= 3 ) , - All clus ters are complia nt a t t his poi nt . 2.4. \"CofferDamReinforcementProfile\" (idx= 4 ) - Las t rei nf orceme nt pro f ile t ype , t here f ore t he s tr o n ges t . Resul t i n g clus ter : { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) , ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , }","title":"Clustering example"},{"location":"reference/koswat_strategies.html#infrastructure-priority","text":"DEFAULT STRATEGY This strategy checks whether the clusters resulting from the order based strategy can change their selected reinforcement to one with cheaper costs. These costs are extracted from the cost report and relate to the reinforcement profile costs (dike's materials for the required space) and the possible infrastructure costs . In steps, this strategy can be broke down as: Steps breakdown : Assignment of order based clusters , Cluster options evaluation, Common available measures cost calculation, Cheapest option selection, Update reinforcement selection with selected option.","title":"Infrastructure priority"},{"location":"reference/koswat_strategies.html#cluster-options","text":"For an optimal assignment of a new reinforcement profile, we make use of \"subclusters\". These subclusters are contiguous subsets from an order based cluster and have the minimal required length ( StrategyInput.reinforcement_min_cluster ). The logic for this section can be found in InfraPriorityStrategy.generate_subcluster_options . For each of original the clusters, multiple combinations of subclusters are possible. We refer to them as \" cluster option \" ( InfraClusterOption ) . We can already discard creating subclusters when the size of the original cluster is less than twice the required minimal length. So for a minimal length of 2 locations, you require a cluster of at least 4 locations to generate subclusters. Conditions : We only create subclusters when the cluster's original size is, at least, twice the required minimal cluster's length. We estimate the cluster's minimal length to be at least twice the size of the buffer so: min_cluster_length = (2 * reinforcement_min_buffer) + 1 . We create subclusters based on the immediate results of the order based strategy . We do not try to combine or create new clusters based on a \"greedier\" strategy.","title":"Cluster options"},{"location":"reference/koswat_strategies.html#cluster-option-example","text":"For example, given the results of the clustering example we can calculate the options for the clusters for a required minimal length of 2 : List of clusters: { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) , ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , } Options for cluster {(0, [\"Location_000\",\"Location_001\",])} - Valid op t io ns : ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) Options for cluster {(3, [\"Location_002\",\"Location_003\", \"Location_004\",\"Location_005\", \"Location_006\",])} - Valid : - {[ \"Location_002\" , \"Location_003\" ], [ \"Location_004\" , \"Location_005\" , \"Location_006\" ]}, - {[ \"Location_002\" , \"Location_003\" , \"Location_004\" ], [ \"Location_005\" , \"Location_006\" ]} - I n valid : - f irs t subclus ter 's size is less t ha n required : {[ \"Location_002\" ], [ \"Location_003\" , \"Location_004\" ], [ \"Location_005\" , \"Location_006\" ]} - las t subclus ter 's size is less t ha n required : {[ \"Location_002\" , \"Location_003\" ], [ \"Location_004\" , \"Location_005\" ], [ \"Location_006\" ]}, - seco n d subclus ter 's size is less t ha n required : {[ \"Location_002\" , \"Location_003\" ], [ \"Location_004\" ], [ \"Location_005\" , \"Location_006\" ]}, - a n d so o n ... Options for cluster {(4, [\"Location_007\",\"Location_008\",\"Location_009\",]),} - Valid : - {[ \"Location_007\" , \"Location_008\" , \"Location_009\" ,]} - I n valid : - f irs t subclus ter 's size is less t ha n required : {[ \"Location_007\" ], [ \"Location_008\" , \"Location_009\" ]} - las t subclus ter 's size is less t ha n required : {[ \"Location_007\" , \"Location_008\" ], [ \"Location_009\" ]} - a n d so o n ...","title":"Cluster option example"},{"location":"reference/koswat_strategies.html#cluster-common-available-measures-cost","text":"Once we have calculated a cluster's option we can determine whether this cluster should be consider as a valid one. This estimation is based on the cheapest reinforcement's cost (including surtax), and to get this value we first need to know which reinforcements are available at all the locations of this option. We will store this value in the InfraClusterOption.cluster_costs . In the current implementation, these costs are added to the InfraClusterOption together with the cluster's data ( list[InfraCluster] ). Conditions : A \"viable\" cluster option must be cheaper than the order's cluster and has the cluster's minimal length. We consider \"minimal costs\" or \"lower costs\" as the lowest cost of applying a certain reinforcement type to a given subcluster.","title":"Cluster common available measures' cost"},{"location":"reference/koswat_strategies.html#common-available-measures-cost-example","text":"Following the options example we can estimate some fictional costs based on the following tables (if a type / location is not mentioned, then assume its cost is zero ( 0 )): Index Reinforcement type base cost incl. surtax 0 Soil reinforcement 42 1 Vertical Piping Solution 420 2 Piping Wall 4.200 3 Stability Wall 42.000 4 Cofferdam 420.000 Location Reinforcement indices Infrastructure cost incl. surtax Location_000 0, 1 4.200.000 Location_005 0, 1, 2, 3 4.200.000 We already know that only the second cluster can generate subclusters, therefore different valid options, so we will use said subcluster's options for the example. 1. De ter mi ne curre nt cos t : - { 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ]} - Base cos ts = 5 * 42.000 = 210.000 - I nfra cos ts = ( 1 ) * 4.200.000 = 4.200.000 - To tal cos ts = 4.410.000 2. Calcula te cos ts f or f irs t op t io n : - { ( 3 , [ \"Location_002\" , \"Location_003\" ], [ \"Location_004\" , \"Location_005\" , \"Location_006\" ] ) }, 1. Firs t subclus ter 's commo n measures : - S ta bili t y Wall (curre nt ) : - Base cos ts = 2 * 42.000 = 84.000 - I nfra cos ts = 0 - To tal cos ts = 42.000 - Co ffer dam : - Base cos ts = 2 * 420.000 = 840.000 - I nfra cos ts = 0 - To tal cos ts = 840.000 - The curre nt rei nf oceme nt is cheaper 2. Seco n d subclus ter 's commo n measures : - S ta bili t y Wall (curre nt ) : - Base cos ts = 3 * 42.000 = 126.000 - I nfra cos ts = ( 1 ) * 4.200.000 = 4.200.000 - To tal cos ts = 4.326.000 - Co ffer dam : - Base cos ts = 3 * 420.000 = 1.260.000 - I nfra cos ts = 0 - To tal cos ts = 1.260.000 - Co ffer dam will be cheaper. 3. Subclus ter 's bes t op t io n is cheaper t ha n curre nt : - { ( 3 , [ \"Location_002\" , \"Location_003\" ] ) , ( 4 , [ \"Location_004\" , \"Location_005\" , \"Location_006\" ] ) } - To tal cos t = 42.000 + 1.260.000 = 1.302.000 - Selec te d as op t io n . 3. Calcula te cos ts f or seco n d op t io n : - { 3 , ( [ \"Location_002\" , \"Location_003\" , \"Location_004\" ], [ \"Location_005\" , \"Location_006\" ] ) } 1. Firs t sublus ter 's commo n measures - S ta bili t y Wall (curre nt ) : - Base cos ts = 3 * 42.000 = 126.000 - I nfra cos ts = 0 - To tal cos ts = 126.000 - Co ffer dam : - Base cos ts = 3 * 420.000 = 1.260.000 - I nfra cos ts = 0 - To tal cos ts = 1.260.000 - The curre nt rei nf oceme nt is cheaper 2. Seco n d sublus ter 's commo n measures - S ta bili t y Wall (curre nt ) : - Base cos ts = 2 * 42.000 = 84.000 - I nfra cos ts = 0 - To tal cos ts = 84.000 - Co ffer dam : - Base cos ts = 2 * 420.000 = 840.000 - I nfra cos ts = 0 - To tal cos ts = 840.000 - Co ffer dam is cheaper 3. Subclus ter 's bes t op t io n is cheaper t ha n selec t io n : - { ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" ] ) , ( 4 , [ \"Location_005\" , \"Location_006\" ] ) } - To tal cos t = 126.000 + 840.000 = 966.000 - Selec te d as op t io n . 4. Upda te loca t io ns ' selec te d rei nf orceme nt : { ( 2 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" ,] ) , ( 4 , [ \"Location_005\" , \"Location_006\" , \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , } In this example we can therefore demonstrate the cost reduction. The last column represents the difference (positive means saved money): O.S. = Order strategy I.S. = Infrastructure priority strategy Location (O.S.) reinforcement (O.S.) cost (I.S.) reinforcement (I.S.) cost Difference Total ---- 6.090.084 ---- 2.226.840 +3.863.244 Location_000 Soil reinforcement 4.200.042 Piping Wall 420 +4.199.622 Location_001 Soil reinforcement 42 Piping Wall 420 -378 Location_002 Stability Wall 42.000 Stability Wall 42.000 0 Location_003 Stability Wall 42.000 Stability Wall 42.000 0 Location_004 Stability Wall 42.000 Stability Wall 42.000 0 Location_005 Stability Wall 462.000 Cofferdam 420.000 +42000 Location_006 Stability Wall 42.000 Cofferdam 420.000 -378000 Location_007 Cofferdam 420.000 Cofferdam 420.000 0 Location_008 Cofferdam 420.000 Cofferdam 420.000 0 Location_009 Cofferdam 420.000 Cofferdam 420.000 0","title":"Common available measures' cost example"},{"location":"reference/koswat_strategies.html#infrastructure-priority-old-approach-example","text":"Important! This example is based on the first approach of this strategy and its steps might differ from the current solution. We left this example as it can help understanding the basic concepts of the strategy. We will start by defining some unrealistic costs per reinforcement type for all locations* such as. For a more realistic scenario check the subclustering example : Index Reinforcement type base cost infra cost total cost 0 Soil reinforcement 42 420.000 420.042 1 Vertical Piping Solution 420 420.000 420.420 2 Piping Wall 4200 0 4200 3 Stability Wall 42.000 420.000 462.000 4 Cofferdam 420.000 0 420.000 Important! For example purposes we are applying the same infrastructure costs to all the locations. |However, in a real case these costs would vary per location (and per reinforcement type). So we can determine the cluster's reinforcement costs as (total cost) * N locations Based on this data Piping Wall will be chosen unless any of the points in the cluster cannot apply it due to obstacles or other constraints, in which case it would end up settling for a Cofferdam reinforcement. Let's see now the strategy steps using the results from the clustering example : 1. Lis t o f clus ters : { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) , ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , } 2. I terate over each clus ter : 2.1. Firs t clus ter is : { ( 0 , [ \"Location_000\" , \"Location_001\" ,] ) } 2.1.1. Ge t t he curre nt cos t o f usi n g t his clus ter . - To tal cos ts * N loca t io ns = `( 420042 ) * 2 = 840084 ` 2.1.2. Ge t cheaper commo n available measures : - Soil Rei nf orceme nt , (idx= 0 ) , - [ Discard ] Curre nt selec t io n . - Ver t ical Pipi n g Solu t io n , (idx= 1 ) , - Cos ts = `( 420.420 ) * 2 = 840.840 ` - [ Discard ] Cos ts are higher t ha n i n i t ial s tate . - Pipi n g Wall , (idx= 2 ) , - Cos ts = `( 4.200 + 0 ) * 2 = 8.400 ` - [ Keep ] Cos ts are cheaper t ha n t he i n i t ial s tate . - S ta bili t y Wall , (idx= 3 ) , - Cos ts = `( 462.000 ) * 2 = 924.000 ` - [ Discard ] Cos ts are higher t ha n i n i t ial s tate . - Co ffer dam , (idx= 3 ) , - Cos ts = `( 420.000 ) * 2 = 840.000 ` - [ Keep ] Cos ts are cheaper t ha n t he i n i t ial s tate , keep. 2.1.3. Se t t he cheapes t commo n available measure per clus ter : - Pipi n g wall < Co ffer dam < Soil rei nf orceme nt (curre nt ) - Pipi n g wall is t he ne w rei nf orceme nt f or t his clus ter . - Resul t : { ( 2 , [ \"Location_000\" , \"Location_001\" ,] ) } 2.2. Seco n d clus ter is : { ( 3 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) } 2.3.1. Ge t t he curre nt cos t o f usi n g t his clus ter . - To tal cos ts * N loca t io ns = `( 462.000 ) * 5 = 2.310.000 ` 2.3.2. Ge t cheaper commo n available measures. - Soil Rei nf orceme nt , (idx= 0 ) , - [ Discard ] No t prese nt a t \"Location_003\" , \"Location_004\" . - Ver t ical Pipi n g Solu t io n , (idx= 1 ) , - [ Discard ] No t prese nt a t \"Location_003\" , \"Location_004\" . - Pipi n g Wall , (idx= 2 ) , - [ Discard ] No t prese nt a t \"Location_003\" , \"Location_004\" . - S ta bili t y Wall , (idx= 3 ) , - [ Discard ] Curre nt selec t io n . - Co ffer dam , (idx= 3 ) , - Cos ts = `( 420.000 ) * 5 = 2.100.000 ` - [ Keep ] Cos ts are cheaper t ha n t he i n i t ial s tate . 2.3.3. Se t t he cheapes t commo n available measure per clus ter : - Co ffer dam < S ta bili t y wall - Co ffer dam is t he ne w rei nf orceme nt f or t his clus ter . - Resul t : { ( 4 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" ,] ) } 2.3. Third clus ter is : { ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) }} 2.3.1. Ge t t he curre nt cos t o f usi n g t his clus ter . - To tal cos ts * N loca t io ns = `( 420.000 ) * 3 = 1.260.000 ` 2.3.2. Ge t cheaper commo n available measures. - Co ffer dam , (idx= 4 ) , - Curre nt selec t io n . 2.3.3. Se t t he cheapes t commo n available measure per clus ter : - O nl y co ffer dam available , - No furt her ac t io n . - Resul t : { ( 4 , [ \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) } 2.4. Resul t i n g clus ters : { ( 2 , [ \"Location_000\" , \"Location_001\" ,] ) , ( 4 , [ \"Location_002\" , \"Location_003\" , \"Location_004\" , \"Location_005\" , \"Location_006\" , \"Location_007\" , \"Location_008\" , \"Location_009\" ,] ) , } With this, we went from: Initial costs: (420.042) * 2 + (462.000) * 5 + (420.000) * 3 = 4.410.084 , to Final costs: (4.200) * 2 + (420.000) * 8 = 3.368.400 Which would amount to a total save of 1.041.684\u20ac","title":"Infrastructure priority (old approach) example"},{"location":"reference/koswat_surroundings.html","text":"Surroundings \u00b6 In koswat's real domain, a dike is surrounded by all sort of surroundings, these could be nature or human-built structures. During our analyisis we make use of ( .shp ) maps where a dike's traject is shown together with all the human-built structures in its proximity. We categorize these structures in the following two types: Obstacles , surroundings that cannot be modified in any way. Infrastructures , as opposite to the obstacles, surroundings that can be repaired or removed and added again (elsewhere). Image 1. Surroundings representation To define said surroundings we make use of .csv files, each file for a specific type of surrounding that needs to be \"enabled\" in the koswat_general.ini settings file. In addition, surroundings can be defined for the inside or the outside of a dike. At the current Koswat version (unreleased v0.15.0 ) we only support surroundings in the inside of a dike ( binnendijks ). Surroundings .csv files \u00b6 The surroundings files follow all the same format both in naming and content. Their file name has the form of T{dike_traject}_{type_of_surrounding}.csv : - The {dike_traject} is the dike's traject code name, usually something like 10_1 , - the {type_of_surrounding} is the name of surrounding that will be imported (check further in the corresponding subsections of obstacles and infrastructure ). Their headers are divided in the following columns: SECTIE , section of the location in the dike's traject, Xcoord , x coordinate of the location, Ycoord , y coordinate of the location, afst_{x}m , distance from the reference point of the location, where 'x' are all the values between 5 and 200 with steps of 5, thus 40 columns. The values in these cells define whether there are obstacles or infrastructures at this distance or not and in Koswat are usually built in the SurroundingsPoint.surroundings_matrix , each type of surrounding interprets the weights in a different manner. Obstacles \u00b6 An obstacle usually represents a building. Because they cannot be removed they become a constraint to the possible reinforcements that can be applied at a given location. For instance, if a dike's reinforcement will become 5 meters wider, but within that distance there are obstacles, said reinforcement will be discarded as a possible option at that location. The distance from the reference point of the dike to the closes point of the obstacle is given. The values in the columns afst_{x}m are either 1 or 0 and are simply interpreted as having a surrounding or not. Thus ignoring other characteristics of the surrounding and just focusing on its presence. Obstacle types \u00b6 Currently we identify and support the following surroundings as written in the .csv file names: bebouwing_binnendijks (buildings), spoorwegen_binnendijks (railways), waters_binnendijks (waters), As reminder, at the moment we only support 'inside the dike's' surroundings. Infrastructures \u00b6 Infrastructures are mostly \"roads\". Contrary to the obstacles these infrastructures do not become a boundary for a reinforcement and they will simply be either displaced or repaired when applying a reinforcement requires their space. When this occurs, it is reflected as additional costs for the given type of reinforcement at that location. In short, these costs are calculated based on: The width of the infrastructure (taken from the Koswat_general.ini settings), The length of the infrastructure at that location (the values in the columns afst_{x}m ), The required technique (repair, displace, nothing) for the type of infrastructure (also from koswat_general.ini settings) and its related costs ( koswat_costs.ini ). With the above values we know what's the affected area of an infrastructure when a reinforced profile needs to be applied and therefore can estimate their costs. The distance from the reference point of the dike to the center point of the infrastructure is given. Infrastructures types \u00b6 Currently we identify and support the following surroundings as written in the .csv file names: wegen_binnendijks_klasse2 (roads class 2), wegen_binnendijks_klasse7 (roads class 7), wegen_binnendijks_klasse24 (roads class 24), wegen_binnendijks_klasse47 (roads class 47), wegen_binnendijks_klasseonbekend (roads of unknown class), As reminder, at the moment we only support 'inside the dike's' surroundings. Surroundings in the code \u00b6 But, how are these surroundings represented in the code? As earlier described, we distinguish surroundings by either obstacles or infrastructures . This is also reflected in the code where we create a general SurroundingsWrapper , which as the name states, wraps the obstacle and infrastructure surroundings in separate properties, each implementing an specialitzation of the BaseSurroundingsWrapper so that: ObstacleSurroundingsWrapper will wrap all the supported obstacle types , in separate properties of type SurroundingsObstacle . InfrastructureSurroundingsWrapper will wrap all the supported infrastructure types , in separate properties of type SurroundingsInfrastructure . A simple diagram illustrating the above can be seen in the image below: Image 2. Surroundings code-wise More detailed information can be found in the corresponding surroundings subproject .","title":"Surroundings"},{"location":"reference/koswat_surroundings.html#surroundings","text":"In koswat's real domain, a dike is surrounded by all sort of surroundings, these could be nature or human-built structures. During our analyisis we make use of ( .shp ) maps where a dike's traject is shown together with all the human-built structures in its proximity. We categorize these structures in the following two types: Obstacles , surroundings that cannot be modified in any way. Infrastructures , as opposite to the obstacles, surroundings that can be repaired or removed and added again (elsewhere). Image 1. Surroundings representation To define said surroundings we make use of .csv files, each file for a specific type of surrounding that needs to be \"enabled\" in the koswat_general.ini settings file. In addition, surroundings can be defined for the inside or the outside of a dike. At the current Koswat version (unreleased v0.15.0 ) we only support surroundings in the inside of a dike ( binnendijks ).","title":"Surroundings"},{"location":"reference/koswat_surroundings.html#surroundings-csv-files","text":"The surroundings files follow all the same format both in naming and content. Their file name has the form of T{dike_traject}_{type_of_surrounding}.csv : - The {dike_traject} is the dike's traject code name, usually something like 10_1 , - the {type_of_surrounding} is the name of surrounding that will be imported (check further in the corresponding subsections of obstacles and infrastructure ). Their headers are divided in the following columns: SECTIE , section of the location in the dike's traject, Xcoord , x coordinate of the location, Ycoord , y coordinate of the location, afst_{x}m , distance from the reference point of the location, where 'x' are all the values between 5 and 200 with steps of 5, thus 40 columns. The values in these cells define whether there are obstacles or infrastructures at this distance or not and in Koswat are usually built in the SurroundingsPoint.surroundings_matrix , each type of surrounding interprets the weights in a different manner.","title":"Surroundings .csv files"},{"location":"reference/koswat_surroundings.html#obstacles","text":"An obstacle usually represents a building. Because they cannot be removed they become a constraint to the possible reinforcements that can be applied at a given location. For instance, if a dike's reinforcement will become 5 meters wider, but within that distance there are obstacles, said reinforcement will be discarded as a possible option at that location. The distance from the reference point of the dike to the closes point of the obstacle is given. The values in the columns afst_{x}m are either 1 or 0 and are simply interpreted as having a surrounding or not. Thus ignoring other characteristics of the surrounding and just focusing on its presence.","title":"Obstacles"},{"location":"reference/koswat_surroundings.html#obstacle-types","text":"Currently we identify and support the following surroundings as written in the .csv file names: bebouwing_binnendijks (buildings), spoorwegen_binnendijks (railways), waters_binnendijks (waters), As reminder, at the moment we only support 'inside the dike's' surroundings.","title":"Obstacle types"},{"location":"reference/koswat_surroundings.html#infrastructures","text":"Infrastructures are mostly \"roads\". Contrary to the obstacles these infrastructures do not become a boundary for a reinforcement and they will simply be either displaced or repaired when applying a reinforcement requires their space. When this occurs, it is reflected as additional costs for the given type of reinforcement at that location. In short, these costs are calculated based on: The width of the infrastructure (taken from the Koswat_general.ini settings), The length of the infrastructure at that location (the values in the columns afst_{x}m ), The required technique (repair, displace, nothing) for the type of infrastructure (also from koswat_general.ini settings) and its related costs ( koswat_costs.ini ). With the above values we know what's the affected area of an infrastructure when a reinforced profile needs to be applied and therefore can estimate their costs. The distance from the reference point of the dike to the center point of the infrastructure is given.","title":"Infrastructures"},{"location":"reference/koswat_surroundings.html#infrastructures-types","text":"Currently we identify and support the following surroundings as written in the .csv file names: wegen_binnendijks_klasse2 (roads class 2), wegen_binnendijks_klasse7 (roads class 7), wegen_binnendijks_klasse24 (roads class 24), wegen_binnendijks_klasse47 (roads class 47), wegen_binnendijks_klasseonbekend (roads of unknown class), As reminder, at the moment we only support 'inside the dike's' surroundings.","title":"Infrastructures types"},{"location":"reference/koswat_surroundings.html#surroundings-in-the-code","text":"But, how are these surroundings represented in the code? As earlier described, we distinguish surroundings by either obstacles or infrastructures . This is also reflected in the code where we create a general SurroundingsWrapper , which as the name states, wraps the obstacle and infrastructure surroundings in separate properties, each implementing an specialitzation of the BaseSurroundingsWrapper so that: ObstacleSurroundingsWrapper will wrap all the supported obstacle types , in separate properties of type SurroundingsObstacle . InfrastructureSurroundingsWrapper will wrap all the supported infrastructure types , in separate properties of type SurroundingsInfrastructure . A simple diagram illustrating the above can be seen in the image below: Image 2. Surroundings code-wise More detailed information can be found in the corresponding surroundings subproject .","title":"Surroundings in the code"},{"location":"reference/koswat_docstrings/cost_report.html","text":"Cost report module \u00b6 CostReportProtocol \u00b6 Bases: Protocol A Protocol defining the properties of a report in Koswat. Infrastructure cost calculator \u00b6 ProfileZoneCalculator dataclass \u00b6 Calculator to determine the width of zones A and B of a reinforced profile ( ReinforcementProfileProtocol ). It requires its original base profile to be in its definition. calculate () -> tuple [ float , float ] \u00b6 Calculates the width of zones A and B for the defined instance of ReinforcementProfileProtocol . The calculation is as follows: - When dh0 has not varied with respect to the base profile, then zones A and B are calculated. - When dh0 has increased then only zone B is calculated. Returns: tuple [ float , float ] \u2013 tuple[float, float]: Calculated zone A and B respectively. InfrastructureProfileCostsCalculator dataclass \u00b6 Calculator to generate all InfrastructureLocationCosts instances based on the locations of the contained infrastructure ( SurroundingsInfrastructure.points ) and the width of zone_a and zone_b . calculate ( zone_a_width : float , zone_b_width : float ) -> list [ InfrastructureLocationCosts ] \u00b6 Calculates the costs affecting this instance's infrastructure at all points where it is present. Parameters: zone_a_width ( float ) \u2013 Width of zone type A . zone_b_width ( float ) \u2013 Width of zone type `B . Returns: list [ InfrastructureLocationCosts ] \u2013 list[InfrastructureLocationCosts]: Resulting cost summaries. MultiInfrastructureProfileCostsCalculator dataclass \u00b6 Calculator that contains all possible \"infrastructure\" calculators ( InfrastructureProfileCostsCalculator ) one for each of the available infrastructures in the current KoswatScenario . Its calculate method only requires a reinforcement ( ReinforcementProfileProtocol ) to determine all infrastructures' costs. calculate ( reinforced_profile : ReinforcementProfileProtocol ) -> list [ InfrastructureLocationProfileCostReport ] \u00b6 Calculates the costs related to appyling the provided reinforcement_profile at all the locations where an infrastructure is present. It first determines zone A and B and then provides their widths to the inner infrastructure calculators ( InfrastructureProfileCostsCalculator ). Parameters: reinforced_profile ( ReinforcementProfileProtocol ) \u2013 Reinforcement to be applied. Returns: list [ InfrastructureLocationProfileCostReport ] \u2013 list[InfrastructureLocationProfileCostReport]: Collection of reports summarizing the cost-impact of a reinforced_profile . MultiInfrastructureProfileCostsCalculatorBuilder dataclass \u00b6 Bases: BuilderProtocol Builder to set up \"fix\" information such as costs derived from the koswat settings ( InfraCostsEnum , SurtaxFactorEnum ) which directly determines the zone A and/or B costs that will be applied for each infrastructure. Quantity cost parameters calculator \u00b6 CostParameterProtocol \u00b6 Bases: Protocol total_cost : float property \u00b6 The total cost (quantity * unit cost) total_cost_with_surtax : float property \u00b6 The total cost including surtaxes IO \u00b6 Summary \u00b6 Summary costs \u00b6 Summary infrastructure costs \u00b6 SummaryInfrastructureCostsCsvFomBuilder dataclass \u00b6 Bases: BuilderProtocol Summary locations \u00b6 ClusterShpFom dataclass \u00b6 base_geometry : LineString property \u00b6 The resulting geometry of all locations excluding the profile's width. Returns: LineString ( LineString ) \u2013 Geometry representing the cluster coordinates. get_buffered_geometry ( width : float ) -> LineString \u00b6 The base_geometry with an applied buffer ( width ) that represents the polderside's width. Parameters: width ( float ) \u2013 Profile's polderside width. Returns: LineString ( LineString ) \u2013 Resulting base_geometry with a buffer. new_profile_width : float property \u00b6 The new polderside width. old_profile_width : float property \u00b6 The original polderside width. ClusterCollectionShpFom dataclass \u00b6 from_summary ( koswat_summary : KoswatSummary , cluster_criteria : Callable [[ StrategyLocationReinforcement ], type [ ReinforcementProfileProtocol ]] = lambda x : x . current_selected_measure ) -> ClusterCollectionShpFom classmethod \u00b6 Maps the KoswatSummary into a file object model that can be exported into *.shp files. Parameters: koswat_summary ( KoswatSummary ) \u2013 The summary containing the information to export. ]) \u2013 (Lambda) Function criteria to group the locations by reinforcement type. Returns: ClusterCollectionShpFom ( ClusterCollectionShpFom ) \u2013 Dataclass instance that can be directly exported into .shp . generate_geodataframes () -> ClusterGeoDataFrameOutputFom \u00b6 Generates all geodataframes of the given clusters. The generated geodataframes correspond to the, base geometry (without buffering), the old and new geometries with their profile's width being buffered to the base geometry. Returns: ClusterGeoDataFrameOutputFom ( ClusterGeoDataFrameOutputFom ) \u2013 Resulting geodataframes wrapper maping this ClusterCollectionShpFom . ClusterGeoDataFrameOutputFom \u00b6 Bases: FileObjectModelProtocol Data structure to wrap the output generated by ClusterCollectionShpFom.generate_geodataframes . is_valid () -> bool \u00b6 Checks that all GeoDataFrame properties are set. Returns: bool ( bool ) \u2013 Validation result.","title":"Cost report module"},{"location":"reference/koswat_docstrings/cost_report.html#cost-report-module","text":"","title":"Cost report module"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.cost_report_protocol.CostReportProtocol","text":"Bases: Protocol A Protocol defining the properties of a report in Koswat.","title":"CostReportProtocol"},{"location":"reference/koswat_docstrings/cost_report.html#infrastructure-cost-calculator","text":"","title":"Infrastructure cost calculator"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.infrastructure.profile_zone_calculator.ProfileZoneCalculator","text":"Calculator to determine the width of zones A and B of a reinforced profile ( ReinforcementProfileProtocol ). It requires its original base profile to be in its definition.","title":"ProfileZoneCalculator"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.infrastructure.profile_zone_calculator.ProfileZoneCalculator.calculate","text":"Calculates the width of zones A and B for the defined instance of ReinforcementProfileProtocol . The calculation is as follows: - When dh0 has not varied with respect to the base profile, then zones A and B are calculated. - When dh0 has increased then only zone B is calculated. Returns: tuple [ float , float ] \u2013 tuple[float, float]: Calculated zone A and B respectively.","title":"calculate"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.infrastructure.infrastructure_profile_costs_calculator.InfrastructureProfileCostsCalculator","text":"Calculator to generate all InfrastructureLocationCosts instances based on the locations of the contained infrastructure ( SurroundingsInfrastructure.points ) and the width of zone_a and zone_b .","title":"InfrastructureProfileCostsCalculator"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.infrastructure.infrastructure_profile_costs_calculator.InfrastructureProfileCostsCalculator.calculate","text":"Calculates the costs affecting this instance's infrastructure at all points where it is present. Parameters: zone_a_width ( float ) \u2013 Width of zone type A . zone_b_width ( float ) \u2013 Width of zone type `B . Returns: list [ InfrastructureLocationCosts ] \u2013 list[InfrastructureLocationCosts]: Resulting cost summaries.","title":"calculate"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.infrastructure.multi_infrastructure_profile_costs_calculator.MultiInfrastructureProfileCostsCalculator","text":"Calculator that contains all possible \"infrastructure\" calculators ( InfrastructureProfileCostsCalculator ) one for each of the available infrastructures in the current KoswatScenario . Its calculate method only requires a reinforcement ( ReinforcementProfileProtocol ) to determine all infrastructures' costs.","title":"MultiInfrastructureProfileCostsCalculator"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.infrastructure.multi_infrastructure_profile_costs_calculator.MultiInfrastructureProfileCostsCalculator.calculate","text":"Calculates the costs related to appyling the provided reinforcement_profile at all the locations where an infrastructure is present. It first determines zone A and B and then provides their widths to the inner infrastructure calculators ( InfrastructureProfileCostsCalculator ). Parameters: reinforced_profile ( ReinforcementProfileProtocol ) \u2013 Reinforcement to be applied. Returns: list [ InfrastructureLocationProfileCostReport ] \u2013 list[InfrastructureLocationProfileCostReport]: Collection of reports summarizing the cost-impact of a reinforced_profile .","title":"calculate"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.infrastructure.multi_infrastructure_profile_costs_calculator_builder.MultiInfrastructureProfileCostsCalculatorBuilder","text":"Bases: BuilderProtocol Builder to set up \"fix\" information such as costs derived from the koswat settings ( InfraCostsEnum , SurtaxFactorEnum ) which directly determines the zone A and/or B costs that will be applied for each infrastructure.","title":"MultiInfrastructureProfileCostsCalculatorBuilder"},{"location":"reference/koswat_docstrings/cost_report.html#quantity-cost-parameters-calculator","text":"","title":"Quantity cost parameters calculator"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.profile.quantity_cost_parameters.CostParameterProtocol","text":"Bases: Protocol","title":"CostParameterProtocol"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.profile.quantity_cost_parameters.CostParameterProtocol.total_cost","text":"The total cost (quantity * unit cost)","title":"total_cost"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.profile.quantity_cost_parameters.CostParameterProtocol.total_cost_with_surtax","text":"The total cost including surtaxes","title":"total_cost_with_surtax"},{"location":"reference/koswat_docstrings/cost_report.html#io","text":"","title":"IO"},{"location":"reference/koswat_docstrings/cost_report.html#summary","text":"","title":"Summary"},{"location":"reference/koswat_docstrings/cost_report.html#summary-costs","text":"","title":"Summary costs"},{"location":"reference/koswat_docstrings/cost_report.html#summary-infrastructure-costs","text":"","title":"Summary infrastructure costs"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_infrastructure_costs.summary_infrastructure_costs_csv_fom_builder.SummaryInfrastructureCostsCsvFomBuilder","text":"Bases: BuilderProtocol","title":"SummaryInfrastructureCostsCsvFomBuilder"},{"location":"reference/koswat_docstrings/cost_report.html#summary-locations","text":"","title":"Summary locations"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_shp_fom.ClusterShpFom","text":"","title":"ClusterShpFom"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_shp_fom.ClusterShpFom.base_geometry","text":"The resulting geometry of all locations excluding the profile's width. Returns: LineString ( LineString ) \u2013 Geometry representing the cluster coordinates.","title":"base_geometry"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_shp_fom.ClusterShpFom.get_buffered_geometry","text":"The base_geometry with an applied buffer ( width ) that represents the polderside's width. Parameters: width ( float ) \u2013 Profile's polderside width. Returns: LineString ( LineString ) \u2013 Resulting base_geometry with a buffer.","title":"get_buffered_geometry"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_shp_fom.ClusterShpFom.new_profile_width","text":"The new polderside width.","title":"new_profile_width"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_shp_fom.ClusterShpFom.old_profile_width","text":"The original polderside width.","title":"old_profile_width"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_collection_shp_fom.ClusterCollectionShpFom","text":"","title":"ClusterCollectionShpFom"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_collection_shp_fom.ClusterCollectionShpFom.from_summary","text":"Maps the KoswatSummary into a file object model that can be exported into *.shp files. Parameters: koswat_summary ( KoswatSummary ) \u2013 The summary containing the information to export. ]) \u2013 (Lambda) Function criteria to group the locations by reinforcement type. Returns: ClusterCollectionShpFom ( ClusterCollectionShpFom ) \u2013 Dataclass instance that can be directly exported into .shp .","title":"from_summary"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_collection_shp_fom.ClusterCollectionShpFom.generate_geodataframes","text":"Generates all geodataframes of the given clusters. The generated geodataframes correspond to the, base geometry (without buffering), the old and new geometries with their profile's width being buffered to the base geometry. Returns: ClusterGeoDataFrameOutputFom ( ClusterGeoDataFrameOutputFom ) \u2013 Resulting geodataframes wrapper maping this ClusterCollectionShpFom .","title":"generate_geodataframes"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_geodataframe_output_fom.ClusterGeoDataFrameOutputFom","text":"Bases: FileObjectModelProtocol Data structure to wrap the output generated by ClusterCollectionShpFom.generate_geodataframes .","title":"ClusterGeoDataFrameOutputFom"},{"location":"reference/koswat_docstrings/cost_report.html#koswat.cost_report.io.summary.summary_locations.cluster_geodataframe_output_fom.ClusterGeoDataFrameOutputFom.is_valid","text":"Checks that all GeoDataFrame properties are set. Returns: bool ( bool ) \u2013 Validation result.","title":"is_valid"},{"location":"reference/koswat_docstrings/koswat_handler.html","text":"Koswat handler \u00b6 KoswatHandler \u00b6 Handler for CLI usage of Koswat . It allows the initialization of a logger during the analysis. __init__ ( log_output : Optional [ str ]) -> None \u00b6 Initializes the handler creating a log file at the optional provided directory log_output . Parameters: log_output ( Optional [ str ] ) \u2013 Directory where to save the koswat.log file. run_analysis ( analysis_file : str ) -> None \u00b6 Runs a Koswat analysis using the provided *.ini file analysis_file . Parameters: analysis_file ( str ) \u2013 Location of the main koswat analysis ini file.","title":"Koswat handler"},{"location":"reference/koswat_docstrings/koswat_handler.html#koswat-handler","text":"","title":"Koswat handler"},{"location":"reference/koswat_docstrings/koswat_handler.html#koswat.koswat_handler.KoswatHandler","text":"Handler for CLI usage of Koswat . It allows the initialization of a logger during the analysis.","title":"KoswatHandler"},{"location":"reference/koswat_docstrings/koswat_handler.html#koswat.koswat_handler.KoswatHandler.__init__","text":"Initializes the handler creating a log file at the optional provided directory log_output . Parameters: log_output ( Optional [ str ] ) \u2013 Directory where to save the koswat.log file.","title":"__init__"},{"location":"reference/koswat_docstrings/koswat_handler.html#koswat.koswat_handler.KoswatHandler.run_analysis","text":"Runs a Koswat analysis using the provided *.ini file analysis_file . Parameters: analysis_file ( str ) \u2013 Location of the main koswat analysis ini file.","title":"run_analysis"},{"location":"reference/koswat_docstrings/koswat_main.html","text":"Main \u00b6 run_analysis ( input_file : str , log_output : str ) \u00b6 CLI call to execute a Koswat analysis given a settings files ( input_file ). The log is generated by default in the execute path, unless otherwise specified in the log_output argument. Parameters: input_file ( str ) \u2013 Location of the *.ini file containing the execution settings for Koswat. log_output ( str ) \u2013 Optional argument to specify where will be created the koswat.log file.","title":"Main"},{"location":"reference/koswat_docstrings/koswat_main.html#main","text":"","title":"Main"},{"location":"reference/koswat_docstrings/koswat_main.html#koswat.__main__.run_analysis","text":"CLI call to execute a Koswat analysis given a settings files ( input_file ). The log is generated by default in the execute path, unless otherwise specified in the log_output argument. Parameters: input_file ( str ) \u2013 Location of the *.ini file containing the execution settings for Koswat. log_output ( str ) \u2013 Optional argument to specify where will be created the koswat.log file.","title":"run_analysis"},{"location":"reference/koswat_docstrings/strategies.html","text":"Strategies \u00b6 StrategyInput dataclass \u00b6 Represents the input data structure for a strategy. reinforcement_min_cluster : int property \u00b6 Returns the minimum length of a reinforcement type along a traject, usually named as cluster throughout the code. Returns: int ( int ) \u2013 Total length StrategyLocationInput dataclass \u00b6 available_measures : list [ type [ ReinforcementProfileProtocol ]] property \u00b6 Gets all the available reinforcement types in strategy_location_reinforcements . It is called available_measures to match the StrategyLocationReinforcement definition. Returns: list [ type [ ReinforcementProfileProtocol ]] \u2013 list[Type[ReinforcementProfileProtocol]]: resulting list. cheapest_reinforcement : StrategyReinforcementTypeCosts property \u00b6 Gets the StrategyLocationReinforcementCosts with the lowest total_costs_with_surtax value. Returns: StrategyLocationReinforcementCosts ( StrategyReinforcementTypeCosts ) \u2013 The cheapest reinforcement for this location. get_infrastructure_costs ( reinforcement_type : type [ ReinforcementProfileProtocol ]) -> tuple [ float , float ] \u00b6 Get the infrastructure costs for the given reinforcement type. Parameters: reinforcement_type ( type [ ReinforcementProfileProtocol ] ) \u2013 The reinforcement type. Raises: ValueError \u2013 The reinforcement type is not available. Returns: tuple [ float , float ] \u2013 tuple[float, float]: Tuple containing the infrastructure costs without and with surtax. get_reinforcement_costs ( reinforcement_type : type [ ReinforcementProfileProtocol ]) -> float \u00b6 Get the costs for the given reinforcement type. Parameters: reinforcement_type ( type [ ReinforcementProfileProtocol ] ) \u2013 The reinforcement type. Raises: ValueError \u2013 The reinforcement type is not available. Returns: float ( float ) \u2013 The reinforcement costs with surtax. StrategyLocationReinforcement dataclass \u00b6 Represents a location and the different reinforcements that can be applied to it as well their costs. This class is used to show the final chosen state for a location. current_cost : float property \u00b6 Estimates the costs with surtax at this location for the given current_selected_measure . current_selected_measure : type [ ReinforcementProfileProtocol ] property \u00b6 Exposes the current selected measure for this object. get_infrastructure_costs ( reinforcement_type : type [ ReinforcementProfileProtocol ]) -> tuple [ float , float ] \u00b6 Returns the infrastructure costs for the given reinforcement type (without and with surtax). Parameters: reinforcement_type ( type [ ReinforcementProfileProtocol ] ) \u2013 Reinforcement type. Returns: tuple [ float , float ] \u2013 tuple[float, float]: Tuple containing the infrastructure costs without and with surtax. get_selected_measure_steps () -> tuple [ type [ ReinforcementProfileProtocol ], type [ ReinforcementProfileProtocol ], type [ ReinforcementProfileProtocol ]] \u00b6 Outputs the selected measure following the domain (expected) steps: - Initial step, - Order step, - Infrastructure step Returns: tuple [ type [ ReinforcementProfileProtocol ], type [ ReinforcementProfileProtocol ], type [ ReinforcementProfileProtocol ]] \u2013 tuple[ type[ReinforcementProfileProtocol], type[ReinforcementProfileProtocol], type[ReinforcementProfileProtocol]]: Resulting tuple. set_selected_measure ( reinforcement_type : type [ ReinforcementProfileProtocol ], step : StrategyStepEnum ) \u00b6 Changes the value reprsented in current_selected_measure and updates the dictionary of selections (history). Parameters: reinforcement_type ( type [ ReinforcementProfileProtocol ] ) \u2013 Reinforcement type step ( StrategyStepsEnum ) \u2013 Step whose StrategyReinforcementTypeCosts dataclass \u00b6 total_costs_with_surtax : float property \u00b6 The simple addition of the base costs and the possible related infrastructure costs, both including surtax. Returns: float ( float ) \u2013 The total costs with surtax when applying this reinforcement. StrategyProtocol \u00b6 Bases: Protocol apply_strategy ( strategy_input : StrategyInput ) -> StrategyOutput \u00b6 Applies a specific strategy by matching each location ( PointSurroundings ) to a valid reinforcement type ( ReinforcementProfileProtocol ). Parameters: strategy_input ( `StrategyInput` ) \u2013 Input data structure containing locations and available reinforcements for each of them. Returns: StrategyOutput ( StrategyOutput ) \u2013 Output data structure containing the selected reinforcements for each location. Order Strategy \u00b6 OrderStrategy \u00b6 Bases: StrategyProtocol get_default_order_for_reinforcements () -> list [ type [ ReinforcementProfileProtocol ]] staticmethod \u00b6 Give the default order for reinforcements types, assuming they are sorted from cheapest to most expensive and least to most restrictive. Returns: list [ type [ ReinforcementProfileProtocol ]] \u2013 list[type[ReinforcementProfileProtocol]]: list of reinforcement types get_strategy_order_for_reinforcements ( strategy_reinforcements : list [ StrategyReinforcementInput ]) -> list [ type [ ReinforcementProfileProtocol ]] \u00b6 Give the ordered reinforcement types for this strategy, from cheapest to most expensive, possibly removing reinforcement types that are more expensive and more restrictive than others. Inactive reinforcements are ignored. Cofferdam should always be the last reinforcement type. Input strategy_reinforcements (list[StrategyReinforcementInput]): list of reinforcement types with costs and surface Returns: list [ type [ ReinforcementProfileProtocol ]] \u2013 list[type[ReinforcementProfileProtocol]]: list of reinforcement types get_strategy_reinforcements ( strategy_locations : list [ StrategyLocationInput ], selection_order : list [ type [ ReinforcementProfileProtocol ]]) -> list [ StrategyLocationReinforcement ] staticmethod \u00b6 Gets the strategy representation of the locations with their available measures ordered filtered and order by the provided selection_order . It also sets their initial state. Parameters: strategy_locations ( list [ StrategyLocationInput ] ) \u2013 Locations to map into reinforcement locations. selection_order ( list [ type [ ReinforcementProfileProtocol ]] ) \u2013 Priority order to assign a reinforcement. Returns: list [ StrategyLocationReinforcement ] \u2013 list[StrategyLocationReinforcement]: Mapped location reinforcements. OrderStrategyBuffering dataclass \u00b6 Bases: OrderStrategyBase Applies buffering, through masks, to each location's pre-assigned reinforcement. The result of the apply method will be the locations with the best reinforcement fit (lowest index from reinforcement_order ) that fulfills the reinforcement_min_buffer requirement. OrderStrategyClustering dataclass \u00b6 Bases: OrderStrategyBase Applies clustering, to the whole collection of reinforcements ( location_reinforcements: list[StrategyLocationReinforcement] ). The result of the apply method will be the locations with the best reinforcement fit (lowest index from reinforcement_order ) that fulfills the reinforcement_min_length requirement. OrderCluster dataclass \u00b6 extend_cluster ( other : OrderCluster ) \u00b6 Extends the current cluster with the reinforcements ( list[StrategyLocationReinforcement] ) from another cluster. Modifies the current_selected_measure property of those measures being merged but it does not remove them from their source cluster. Parameters: other ( OrderCluster ) \u2013 Cluster whose contents will be used to extend self . Raises: ValueError \u2013 When trying to extend from an unrelated cluster. get_stronger_cluster () -> OrderCluster \u00b6 Gets the neighbor with the lowest reinforcement type value greater than the current cluster's value ( self.reinforcement_idx ). Returns: OrderCluster ( OrderCluster ) \u2013 Neighbor with a stronger ReinforcementProfileProtocol . is_compliant ( min_length : float , strongest_reinforcement : int ) -> bool \u00b6 Checks whether this OrderCluster instance is compliant within a cluster group. This method does not check for exceptions, such as, the cluster's neighbors are of lower strength than the current. Parameters: min_length ( float ) \u2013 Minimal length a reinforcement measure is required for a cluster. strongest_reinforcement ( int ) \u2013 What is the reinforcement index which cannot be futher 'strengthen'. Returns: bool ( bool ) \u2013 if the cluster is compliant within its neighbors context. Infra Priority Strategy \u00b6 InfraPriorityStrategy \u00b6 Bases: StrategyProtocol This strategy works under the assumption that StrategyLocationReinforcement.available_measures ARE NOT ordered by \"compatibility\". Thus we need to check first which are the compatible reinforcements per cluster. generate_subcluster_options ( from_cluster : InfraCluster , min_length : int ) -> list [ list [ InfraCluster ]] staticmethod \u00b6 Generates all possible combinations of (sub) clusters based on the locations of this cluster. These are also referred as \"options\". Parameters: min_length ( int ) \u2013 Minimum length for a cluster to be valid. Returns: list [ list [ InfraCluster ]] \u2013 list[list[InfraCluster]]: Collection of \"options\" with valid length. get_common_available_measures_costs ( infra_cluster : InfraCluster , order_strategy_reinforcements : list [ type [ ReinforcementProfileProtocol ]]) -> dict [ type [ ReinforcementProfileProtocol ], float ] staticmethod \u00b6 Gets a dictionary with the reinforcements available at all locations of the cluster ( infra_cluster ) as well as their total cost if said reinforcement is applied at them. Parameters: infra_cluster ( InfraCluster ) \u2013 Cluster being analyzed. order_strategy_reinforcements ( list [ type [ ReinforcementProfileProtocol ]] ) \u2013 Reinforcements ordered by base cost (ground surface). Returns: dict [ type [ ReinforcementProfileProtocol ], float ] \u2013 dict[type[ReinforcementProfileProtocol], float]: Resulting reinforcement type - costs dictionary. InfraCluster dataclass \u00b6 This dataclass represents the subset of locations sharing the same reinforcement type ( type[ReinforcementProfileProtocol] ). current_cost : float property \u00b6 Calculates the cost of applying the reinforcement_type to all locations present in the cluster . Returns: float ( float ) \u2013 The total (current) cost of this cluster. fits_subclusters () -> bool \u00b6 Validates whether this cluster can be split into subclusters. For that it requires to have at least twice the required length. Returns: bool ( bool ) \u2013 Whether subclusters can be generated from this one. is_valid () -> bool \u00b6 Validates the length of this cluster. Returns: bool ( bool ) \u2013 The cluster has the minimal required length. set_cheapest_common_available_measure ( measure_costs : dict [ type [ ReinforcementProfileProtocol ], float ]) -> None \u00b6 Updates all the location reinforcements with the cheapest reinforcement type from the measure_costs . Parameters: measure_costs ( dict [ type [ ReinforcementProfileProtocol ]] ) \u2013 dictionary with the total costs per reinforcement type. InfraClusterOption dataclass \u00b6 Represents one set of subclusters the strategy could select for costs optimization. add_cluster ( infra_cluster : InfraCluster , cluster_costs : dict ) \u00b6 Adds the infra cluster into the collection as well as its reinforcement costs. Parameters: infra_cluster ( InfraCluster ) \u2013 Cluster to add to this collection option. cluster_costs ( dict ) \u2013 Reinforcement costs for the given cluster. cluster_collection : list [ InfraCluster ] property \u00b6 Read-only property to expose the stored subclusters. cluster_costs : list [ dict [ ReinforcementProfileProtocol , float ]] property \u00b6 Read-only property to expose the stored costs. set_cheapest_option () \u00b6 Sets the subclusters defined in this option to their most optimal (cheapest) reinforcement possible. valid_option () -> bool \u00b6 Validates the collection of clusters based on the required minimun length. Returns: bool ( bool ) \u2013 Validation result. Strategy step \u00b6","title":"Strategies"},{"location":"reference/koswat_docstrings/strategies.html#strategies","text":"","title":"Strategies"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_input.StrategyInput","text":"Represents the input data structure for a strategy.","title":"StrategyInput"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_input.StrategyInput.reinforcement_min_cluster","text":"Returns the minimum length of a reinforcement type along a traject, usually named as cluster throughout the code. Returns: int ( int ) \u2013 Total length","title":"reinforcement_min_cluster"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_input.StrategyLocationInput","text":"","title":"StrategyLocationInput"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_input.StrategyLocationInput.available_measures","text":"Gets all the available reinforcement types in strategy_location_reinforcements . It is called available_measures to match the StrategyLocationReinforcement definition. Returns: list [ type [ ReinforcementProfileProtocol ]] \u2013 list[Type[ReinforcementProfileProtocol]]: resulting list.","title":"available_measures"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_input.StrategyLocationInput.cheapest_reinforcement","text":"Gets the StrategyLocationReinforcementCosts with the lowest total_costs_with_surtax value. Returns: StrategyLocationReinforcementCosts ( StrategyReinforcementTypeCosts ) \u2013 The cheapest reinforcement for this location.","title":"cheapest_reinforcement"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_input.StrategyLocationInput.get_infrastructure_costs","text":"Get the infrastructure costs for the given reinforcement type. Parameters: reinforcement_type ( type [ ReinforcementProfileProtocol ] ) \u2013 The reinforcement type. Raises: ValueError \u2013 The reinforcement type is not available. Returns: tuple [ float , float ] \u2013 tuple[float, float]: Tuple containing the infrastructure costs without and with surtax.","title":"get_infrastructure_costs"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_input.StrategyLocationInput.get_reinforcement_costs","text":"Get the costs for the given reinforcement type. Parameters: reinforcement_type ( type [ ReinforcementProfileProtocol ] ) \u2013 The reinforcement type. Raises: ValueError \u2013 The reinforcement type is not available. Returns: float ( float ) \u2013 The reinforcement costs with surtax.","title":"get_reinforcement_costs"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_reinforcement.StrategyLocationReinforcement","text":"Represents a location and the different reinforcements that can be applied to it as well their costs. This class is used to show the final chosen state for a location.","title":"StrategyLocationReinforcement"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_reinforcement.StrategyLocationReinforcement.current_cost","text":"Estimates the costs with surtax at this location for the given current_selected_measure .","title":"current_cost"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_reinforcement.StrategyLocationReinforcement.current_selected_measure","text":"Exposes the current selected measure for this object.","title":"current_selected_measure"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_reinforcement.StrategyLocationReinforcement.get_infrastructure_costs","text":"Returns the infrastructure costs for the given reinforcement type (without and with surtax). Parameters: reinforcement_type ( type [ ReinforcementProfileProtocol ] ) \u2013 Reinforcement type. Returns: tuple [ float , float ] \u2013 tuple[float, float]: Tuple containing the infrastructure costs without and with surtax.","title":"get_infrastructure_costs"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_reinforcement.StrategyLocationReinforcement.get_selected_measure_steps","text":"Outputs the selected measure following the domain (expected) steps: - Initial step, - Order step, - Infrastructure step Returns: tuple [ type [ ReinforcementProfileProtocol ], type [ ReinforcementProfileProtocol ], type [ ReinforcementProfileProtocol ]] \u2013 tuple[ type[ReinforcementProfileProtocol], type[ReinforcementProfileProtocol], type[ReinforcementProfileProtocol]]: Resulting tuple.","title":"get_selected_measure_steps"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_location_reinforcement.StrategyLocationReinforcement.set_selected_measure","text":"Changes the value reprsented in current_selected_measure and updates the dictionary of selections (history). Parameters: reinforcement_type ( type [ ReinforcementProfileProtocol ] ) \u2013 Reinforcement type step ( StrategyStepsEnum ) \u2013 Step whose","title":"set_selected_measure"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_reinforcement_type_costs.StrategyReinforcementTypeCosts","text":"","title":"StrategyReinforcementTypeCosts"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_reinforcement_type_costs.StrategyReinforcementTypeCosts.total_costs_with_surtax","text":"The simple addition of the base costs and the possible related infrastructure costs, both including surtax. Returns: float ( float ) \u2013 The total costs with surtax when applying this reinforcement.","title":"total_costs_with_surtax"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_protocol.StrategyProtocol","text":"Bases: Protocol","title":"StrategyProtocol"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.strategy_protocol.StrategyProtocol.apply_strategy","text":"Applies a specific strategy by matching each location ( PointSurroundings ) to a valid reinforcement type ( ReinforcementProfileProtocol ). Parameters: strategy_input ( `StrategyInput` ) \u2013 Input data structure containing locations and available reinforcements for each of them. Returns: StrategyOutput ( StrategyOutput ) \u2013 Output data structure containing the selected reinforcements for each location.","title":"apply_strategy"},{"location":"reference/koswat_docstrings/strategies.html#order-strategy","text":"","title":"Order Strategy"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_strategy.OrderStrategy","text":"Bases: StrategyProtocol","title":"OrderStrategy"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_strategy.OrderStrategy.get_default_order_for_reinforcements","text":"Give the default order for reinforcements types, assuming they are sorted from cheapest to most expensive and least to most restrictive. Returns: list [ type [ ReinforcementProfileProtocol ]] \u2013 list[type[ReinforcementProfileProtocol]]: list of reinforcement types","title":"get_default_order_for_reinforcements"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_strategy.OrderStrategy.get_strategy_order_for_reinforcements","text":"Give the ordered reinforcement types for this strategy, from cheapest to most expensive, possibly removing reinforcement types that are more expensive and more restrictive than others. Inactive reinforcements are ignored. Cofferdam should always be the last reinforcement type. Input strategy_reinforcements (list[StrategyReinforcementInput]): list of reinforcement types with costs and surface Returns: list [ type [ ReinforcementProfileProtocol ]] \u2013 list[type[ReinforcementProfileProtocol]]: list of reinforcement types","title":"get_strategy_order_for_reinforcements"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_strategy.OrderStrategy.get_strategy_reinforcements","text":"Gets the strategy representation of the locations with their available measures ordered filtered and order by the provided selection_order . It also sets their initial state. Parameters: strategy_locations ( list [ StrategyLocationInput ] ) \u2013 Locations to map into reinforcement locations. selection_order ( list [ type [ ReinforcementProfileProtocol ]] ) \u2013 Priority order to assign a reinforcement. Returns: list [ StrategyLocationReinforcement ] \u2013 list[StrategyLocationReinforcement]: Mapped location reinforcements.","title":"get_strategy_reinforcements"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_strategy_buffering.OrderStrategyBuffering","text":"Bases: OrderStrategyBase Applies buffering, through masks, to each location's pre-assigned reinforcement. The result of the apply method will be the locations with the best reinforcement fit (lowest index from reinforcement_order ) that fulfills the reinforcement_min_buffer requirement.","title":"OrderStrategyBuffering"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_strategy_clustering.OrderStrategyClustering","text":"Bases: OrderStrategyBase Applies clustering, to the whole collection of reinforcements ( location_reinforcements: list[StrategyLocationReinforcement] ). The result of the apply method will be the locations with the best reinforcement fit (lowest index from reinforcement_order ) that fulfills the reinforcement_min_length requirement.","title":"OrderStrategyClustering"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_cluster.OrderCluster","text":"","title":"OrderCluster"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_cluster.OrderCluster.extend_cluster","text":"Extends the current cluster with the reinforcements ( list[StrategyLocationReinforcement] ) from another cluster. Modifies the current_selected_measure property of those measures being merged but it does not remove them from their source cluster. Parameters: other ( OrderCluster ) \u2013 Cluster whose contents will be used to extend self . Raises: ValueError \u2013 When trying to extend from an unrelated cluster.","title":"extend_cluster"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_cluster.OrderCluster.get_stronger_cluster","text":"Gets the neighbor with the lowest reinforcement type value greater than the current cluster's value ( self.reinforcement_idx ). Returns: OrderCluster ( OrderCluster ) \u2013 Neighbor with a stronger ReinforcementProfileProtocol .","title":"get_stronger_cluster"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.order_strategy.order_cluster.OrderCluster.is_compliant","text":"Checks whether this OrderCluster instance is compliant within a cluster group. This method does not check for exceptions, such as, the cluster's neighbors are of lower strength than the current. Parameters: min_length ( float ) \u2013 Minimal length a reinforcement measure is required for a cluster. strongest_reinforcement ( int ) \u2013 What is the reinforcement index which cannot be futher 'strengthen'. Returns: bool ( bool ) \u2013 if the cluster is compliant within its neighbors context.","title":"is_compliant"},{"location":"reference/koswat_docstrings/strategies.html#infra-priority-strategy","text":"","title":"Infra Priority Strategy"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_priority_strategy.InfraPriorityStrategy","text":"Bases: StrategyProtocol This strategy works under the assumption that StrategyLocationReinforcement.available_measures ARE NOT ordered by \"compatibility\". Thus we need to check first which are the compatible reinforcements per cluster.","title":"InfraPriorityStrategy"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_priority_strategy.InfraPriorityStrategy.generate_subcluster_options","text":"Generates all possible combinations of (sub) clusters based on the locations of this cluster. These are also referred as \"options\". Parameters: min_length ( int ) \u2013 Minimum length for a cluster to be valid. Returns: list [ list [ InfraCluster ]] \u2013 list[list[InfraCluster]]: Collection of \"options\" with valid length.","title":"generate_subcluster_options"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_priority_strategy.InfraPriorityStrategy.get_common_available_measures_costs","text":"Gets a dictionary with the reinforcements available at all locations of the cluster ( infra_cluster ) as well as their total cost if said reinforcement is applied at them. Parameters: infra_cluster ( InfraCluster ) \u2013 Cluster being analyzed. order_strategy_reinforcements ( list [ type [ ReinforcementProfileProtocol ]] ) \u2013 Reinforcements ordered by base cost (ground surface). Returns: dict [ type [ ReinforcementProfileProtocol ], float ] \u2013 dict[type[ReinforcementProfileProtocol], float]: Resulting reinforcement type - costs dictionary.","title":"get_common_available_measures_costs"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster.InfraCluster","text":"This dataclass represents the subset of locations sharing the same reinforcement type ( type[ReinforcementProfileProtocol] ).","title":"InfraCluster"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster.InfraCluster.current_cost","text":"Calculates the cost of applying the reinforcement_type to all locations present in the cluster . Returns: float ( float ) \u2013 The total (current) cost of this cluster.","title":"current_cost"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster.InfraCluster.fits_subclusters","text":"Validates whether this cluster can be split into subclusters. For that it requires to have at least twice the required length. Returns: bool ( bool ) \u2013 Whether subclusters can be generated from this one.","title":"fits_subclusters"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster.InfraCluster.is_valid","text":"Validates the length of this cluster. Returns: bool ( bool ) \u2013 The cluster has the minimal required length.","title":"is_valid"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster.InfraCluster.set_cheapest_common_available_measure","text":"Updates all the location reinforcements with the cheapest reinforcement type from the measure_costs . Parameters: measure_costs ( dict [ type [ ReinforcementProfileProtocol ]] ) \u2013 dictionary with the total costs per reinforcement type.","title":"set_cheapest_common_available_measure"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster_option.InfraClusterOption","text":"Represents one set of subclusters the strategy could select for costs optimization.","title":"InfraClusterOption"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster_option.InfraClusterOption.add_cluster","text":"Adds the infra cluster into the collection as well as its reinforcement costs. Parameters: infra_cluster ( InfraCluster ) \u2013 Cluster to add to this collection option. cluster_costs ( dict ) \u2013 Reinforcement costs for the given cluster.","title":"add_cluster"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster_option.InfraClusterOption.cluster_collection","text":"Read-only property to expose the stored subclusters.","title":"cluster_collection"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster_option.InfraClusterOption.cluster_costs","text":"Read-only property to expose the stored costs.","title":"cluster_costs"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster_option.InfraClusterOption.set_cheapest_option","text":"Sets the subclusters defined in this option to their most optimal (cheapest) reinforcement possible.","title":"set_cheapest_option"},{"location":"reference/koswat_docstrings/strategies.html#koswat.strategies.infra_priority_strategy.infra_cluster_option.InfraClusterOption.valid_option","text":"Validates the collection of clusters based on the required minimun length. Returns: bool ( bool ) \u2013 Validation result.","title":"valid_option"},{"location":"reference/koswat_docstrings/strategies.html#strategy-step","text":"","title":"Strategy step"},{"location":"reference/koswat_docstrings/configuration/koswat_config_protocol.html","text":"Koswat Config Protocol \u00b6 KoswatConfigProtocol \u00b6 Bases: DataObjectModelProtocol , Protocol is_valid () -> bool \u00b6 Validates the current KoswatConfigProtocol instance. Returns: bool ( bool ) \u2013 True when the current instance is valid to be used as a configuration class.","title":"Koswat Config Protocol"},{"location":"reference/koswat_docstrings/configuration/koswat_config_protocol.html#koswat-config-protocol","text":"","title":"Koswat Config Protocol"},{"location":"reference/koswat_docstrings/configuration/koswat_config_protocol.html#koswat.configuration.koswat_config_protocol.KoswatConfigProtocol","text":"Bases: DataObjectModelProtocol , Protocol","title":"KoswatConfigProtocol"},{"location":"reference/koswat_docstrings/configuration/koswat_config_protocol.html#koswat.configuration.koswat_config_protocol.KoswatConfigProtocol.is_valid","text":"Validates the current KoswatConfigProtocol instance. Returns: bool ( bool ) \u2013 True when the current instance is valid to be used as a configuration class.","title":"is_valid"},{"location":"reference/koswat_docstrings/core/geometries.html","text":"Core geometries module \u00b6 as_unified_geometry ( source_geom : geometry . Polygon | geometry . MultiPolygon ) -> geometry . Polygon \u00b6 Ensures the calculated geometry is returned as a single polygon. Parameters: source_geom ( Polygon | MultiPolygon ) \u2013 Calculated source geometry. Returns: Polygon \u2013 geometry.Polygon: Unified resulting geometry with its points ordered (first one is the most-left x coordinate). get_groundlevel_surface ( pol_geometry : geometry . Polygon ) -> geometry . LineString \u00b6 Returns all the points which are at 'groundlevel' values (y = 0) Parameters: pol_geometry ( Polygon ) \u2013 Source geometry. Returns: LineString \u2013 geometry.LineString: Line with points at y = 0. get_normalized_polygon_difference ( left_geom : geometry . Polygon , right_geom : geometry . Polygon ) -> geometry . Polygon | geometry . MultiPolygon \u00b6 Given two polygons calculates the difference between them and removes any residual polygon due to minor precision errors. Parameters: left_geom ( Polygon ) \u2013 Base polygon from where to substract. right_geom ( Polygon ) \u2013 Polygon to substract from base. Returns: Polygon | MultiPolygon \u2013 geometry.Polygon: Resulting normalized substraction polygon. get_polygon_coordinates ( pol_geometry : geometry . Polygon | geometry . MultiPolygon ) -> geometry . LineString \u00b6 Given a single or multi geometry returns the coordinates composing its outer layout. Parameters: pol_geometry ( Polygon | MultiPolygon ) \u2013 Source geometry. Raises: NotImplementedError \u2013 When the provided geometry is not yet supported. Returns: LineString \u2013 geometry.LineString: Set of points composing the outer layout of the geometry. get_polygon_surface_points ( base_geometry : geometry . Polygon | geometry . MultiPolygon ) -> geometry . LineString \u00b6 Gets all the points composing the upper surface of a 'dike' geometry. IMPORTANT! The calling of this method assumes the base_geometry points are in order, call order_geometry_points if needed. Parameters: base_geometry ( Union [ Polygon , MultiPolygon ] ) \u2013 Source geometry. Returns: LineString \u2013 geometry.LineString: Resulting line with points from the outer geometry. get_relative_core_layer ( core_geometry : geometry . Polygon , coating_geometry : geometry . Polygon ) -> geometry . Polygon \u00b6 Returns a new 'core' from the original core_geometry relative to the coating_geometry . Parameters: core_geometry ( Polygon ) \u2013 Original core geometry on which layers are stacked upon. coating_geometry ( Polygon ) \u2013 Layer wrapping the exterior of a core geometry. Returns: Polygon ( Polygon ) \u2013 Layer wrapping a reduced surface of the core_geometry . order_geometry_points ( dike_polygon : geometry . Polygon ) -> geometry . Polygon \u00b6 In koswat we handle polygon operations expecting the lowest 'x' coordinate to be the initial and last point of a geometry. For this reason we need to ensure all geometries are 'normalized' based on this criteria. Parameters: dike_polygon ( Polygon ) \u2013 Polygon to normalized. Returns: Polygon \u2013 geometry.Polygon: Normalized polygon. profile_points_to_polygon ( points_list : list [ geometry . Point ]) -> geometry . Polygon \u00b6 Transforms a list of points into a valid 'dike' polygon. When there is a difference in height between left and right side then we correct it in the x = 0 coordinate. Parameters: points_list ( List [ Point ] ) \u2013 List of points representing a dike profile. Returns: Polygon \u2013 geometry.Polygon: Validated enclosed geometry simple polygon. remove_layer_from_polygon ( dike_polygon : geometry . Polygon , layer_depth : float ) -> geometry . Polygon \u00b6 Gets the dike profile without a layer of provided layer_depth depth. Parameters: dike_polygon ( Polygon ) \u2013 Source geometry. layer_depth ( float ) \u2013 Depth of a layer from the outer dike_polygon geometry inwards. Returns: Polygon \u2013 geometry.Polygon: Resulting geometry when removing the layer.","title":"Core geometries module"},{"location":"reference/koswat_docstrings/core/geometries.html#core-geometries-module","text":"","title":"Core geometries module"},{"location":"reference/koswat_docstrings/core/geometries.html#koswat.core.geometries.calc_library.as_unified_geometry","text":"Ensures the calculated geometry is returned as a single polygon. Parameters: source_geom ( Polygon | MultiPolygon ) \u2013 Calculated source geometry. Returns: Polygon \u2013 geometry.Polygon: Unified resulting geometry with its points ordered (first one is the most-left x coordinate).","title":"as_unified_geometry"},{"location":"reference/koswat_docstrings/core/geometries.html#koswat.core.geometries.calc_library.get_groundlevel_surface","text":"Returns all the points which are at 'groundlevel' values (y = 0) Parameters: pol_geometry ( Polygon ) \u2013 Source geometry. Returns: LineString \u2013 geometry.LineString: Line with points at y = 0.","title":"get_groundlevel_surface"},{"location":"reference/koswat_docstrings/core/geometries.html#koswat.core.geometries.calc_library.get_normalized_polygon_difference","text":"Given two polygons calculates the difference between them and removes any residual polygon due to minor precision errors. Parameters: left_geom ( Polygon ) \u2013 Base polygon from where to substract. right_geom ( Polygon ) \u2013 Polygon to substract from base. Returns: Polygon | MultiPolygon \u2013 geometry.Polygon: Resulting normalized substraction polygon.","title":"get_normalized_polygon_difference"},{"location":"reference/koswat_docstrings/core/geometries.html#koswat.core.geometries.calc_library.get_polygon_coordinates","text":"Given a single or multi geometry returns the coordinates composing its outer layout. Parameters: pol_geometry ( Polygon | MultiPolygon ) \u2013 Source geometry. Raises: NotImplementedError \u2013 When the provided geometry is not yet supported. Returns: LineString \u2013 geometry.LineString: Set of points composing the outer layout of the geometry.","title":"get_polygon_coordinates"},{"location":"reference/koswat_docstrings/core/geometries.html#koswat.core.geometries.calc_library.get_polygon_surface_points","text":"Gets all the points composing the upper surface of a 'dike' geometry. IMPORTANT! The calling of this method assumes the base_geometry points are in order, call order_geometry_points if needed. Parameters: base_geometry ( Union [ Polygon , MultiPolygon ] ) \u2013 Source geometry. Returns: LineString \u2013 geometry.LineString: Resulting line with points from the outer geometry.","title":"get_polygon_surface_points"},{"location":"reference/koswat_docstrings/core/geometries.html#koswat.core.geometries.calc_library.get_relative_core_layer","text":"Returns a new 'core' from the original core_geometry relative to the coating_geometry . Parameters: core_geometry ( Polygon ) \u2013 Original core geometry on which layers are stacked upon. coating_geometry ( Polygon ) \u2013 Layer wrapping the exterior of a core geometry. Returns: Polygon ( Polygon ) \u2013 Layer wrapping a reduced surface of the core_geometry .","title":"get_relative_core_layer"},{"location":"reference/koswat_docstrings/core/geometries.html#koswat.core.geometries.calc_library.order_geometry_points","text":"In koswat we handle polygon operations expecting the lowest 'x' coordinate to be the initial and last point of a geometry. For this reason we need to ensure all geometries are 'normalized' based on this criteria. Parameters: dike_polygon ( Polygon ) \u2013 Polygon to normalized. Returns: Polygon \u2013 geometry.Polygon: Normalized polygon.","title":"order_geometry_points"},{"location":"reference/koswat_docstrings/core/geometries.html#koswat.core.geometries.calc_library.profile_points_to_polygon","text":"Transforms a list of points into a valid 'dike' polygon. When there is a difference in height between left and right side then we correct it in the x = 0 coordinate. Parameters: points_list ( List [ Point ] ) \u2013 List of points representing a dike profile. Returns: Polygon \u2013 geometry.Polygon: Validated enclosed geometry simple polygon.","title":"profile_points_to_polygon"},{"location":"reference/koswat_docstrings/core/geometries.html#koswat.core.geometries.calc_library.remove_layer_from_polygon","text":"Gets the dike profile without a layer of provided layer_depth depth. Parameters: dike_polygon ( Polygon ) \u2013 Source geometry. layer_depth ( float ) \u2013 Depth of a layer from the outer dike_polygon geometry inwards. Returns: Polygon \u2013 geometry.Polygon: Resulting geometry when removing the layer.","title":"remove_layer_from_polygon"},{"location":"reference/koswat_docstrings/core/io.html","text":"Input Output core module \u00b6 FileObjectModelProtocol \u00b6 Bases: Protocol is_valid () -> bool \u00b6 Verifies if the current object is valid for import / export. Returns: bool ( bool ) \u2013 Result of the validation. KoswatExporterProtocol \u00b6 Bases: Protocol export ( ** kwargs ) -> None \u00b6 Exports an object model into a concrete file format. KoswatImporterProtocol \u00b6 Bases: Protocol import_from ( from_path : Path ) -> DataObjectModelProtocol | list [ DataObjectModelProtocol ] \u00b6 Generates a valid instance of a DataObjectModelProtocol based on the contents from the provided path. Parameters: from_path ( Path ) \u2013 Path containing data to be read (file or directory). Returns: DataObjectModelProtocol | list [ DataObjectModelProtocol ] \u2013 DataObjectModelProtocol | list[DataObjectModelProtocol]: Either a single valid instance of a DataObjectModelProtocol or a list of them. KoswatReaderProtocol \u00b6 Bases: Protocol read ( file_path : Path ) -> FileObjectModelProtocol \u00b6 Imports the data from the file_path into a concrete implementation of a FileObjectModelProtocol . Parameters: file_path ( Path ) \u2013 Path to a file that should be imported. Returns: FileObjectModelProtocol ( FileObjectModelProtocol ) \u2013 Model representing the data in the file. supports_file ( file_path : Path ) -> bool \u00b6 Validates whether the current reader is capable of importing data from the provided file. Parameters: file_path ( Path ) \u2013 Path to a file that should be imported. Returns: bool ( bool ) \u2013 Result of validation. KoswatWriterProtocol \u00b6 Bases: Protocol write ( fom_instance : FileObjectModelProtocol , to_path : Path ) -> None \u00b6 Writes the data from the instance of a FileObjectModelProtocol to the to_path . Parameters: fom_instance ( FileObjectModelProtocol ) \u2013 Instance with data to write. to_path ( Path ) \u2013 Path to file (or directory) where to write the data. CSV module \u00b6 KoswatCsvFomProtocol \u00b6 Bases: FileObjectModelProtocol , Protocol is_valid () -> bool \u00b6 Validates the current structure of this KoswatCsvFomProtocol instance. Returns: bool ( bool ) \u2013 True when is a valid FOM. INI module \u00b6 KoswatIniFomProtocol \u00b6 Bases: FileObjectModelProtocol , Protocol from_config ( ini_config : ConfigParser ) -> KoswatIniFomProtocol classmethod \u00b6 Imports all the data stored in an dictionary into a KoswatIniFomProtocol instance. Parameters: ini_config ( ConfigParser ) \u2013 Dictionary containing Ini values (section - properties, property - value) to be parsed. Returns: KoswatIniFomProtocol ( KoswatIniFomProtocol ) \u2013 Valid instance of a KoswatIniFomProtocol with the provided values. TXT module \u00b6 KoswatTxtFomProtocol \u00b6 Bases: FileObjectModelProtocol , Protocol from_text ( file_text : str ) -> KoswatTxtFomProtocol classmethod \u00b6 Imports all the data stored in text form. Parameters: file_text ( str ) \u2013 Raw data in string format. Returns: KoswatTxtFomProtocol ( KoswatTxtFomProtocol ) \u2013 Valid instance of a KoswatTxtFomProtocol with the provided values.","title":"Input Output core module"},{"location":"reference/koswat_docstrings/core/io.html#input-output-core-module","text":"","title":"Input Output core module"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.file_object_model_protocol.FileObjectModelProtocol","text":"Bases: Protocol","title":"FileObjectModelProtocol"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.file_object_model_protocol.FileObjectModelProtocol.is_valid","text":"Verifies if the current object is valid for import / export. Returns: bool ( bool ) \u2013 Result of the validation.","title":"is_valid"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.koswat_exporter_protocol.KoswatExporterProtocol","text":"Bases: Protocol","title":"KoswatExporterProtocol"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.koswat_exporter_protocol.KoswatExporterProtocol.export","text":"Exports an object model into a concrete file format.","title":"export"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.koswat_importer_protocol.KoswatImporterProtocol","text":"Bases: Protocol","title":"KoswatImporterProtocol"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.koswat_importer_protocol.KoswatImporterProtocol.import_from","text":"Generates a valid instance of a DataObjectModelProtocol based on the contents from the provided path. Parameters: from_path ( Path ) \u2013 Path containing data to be read (file or directory). Returns: DataObjectModelProtocol | list [ DataObjectModelProtocol ] \u2013 DataObjectModelProtocol | list[DataObjectModelProtocol]: Either a single valid instance of a DataObjectModelProtocol or a list of them.","title":"import_from"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.koswat_reader_protocol.KoswatReaderProtocol","text":"Bases: Protocol","title":"KoswatReaderProtocol"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.koswat_reader_protocol.KoswatReaderProtocol.read","text":"Imports the data from the file_path into a concrete implementation of a FileObjectModelProtocol . Parameters: file_path ( Path ) \u2013 Path to a file that should be imported. Returns: FileObjectModelProtocol ( FileObjectModelProtocol ) \u2013 Model representing the data in the file.","title":"read"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.koswat_reader_protocol.KoswatReaderProtocol.supports_file","text":"Validates whether the current reader is capable of importing data from the provided file. Parameters: file_path ( Path ) \u2013 Path to a file that should be imported. Returns: bool ( bool ) \u2013 Result of validation.","title":"supports_file"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.koswat_writer_protocol.KoswatWriterProtocol","text":"Bases: Protocol","title":"KoswatWriterProtocol"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.koswat_writer_protocol.KoswatWriterProtocol.write","text":"Writes the data from the instance of a FileObjectModelProtocol to the to_path . Parameters: fom_instance ( FileObjectModelProtocol ) \u2013 Instance with data to write. to_path ( Path ) \u2013 Path to file (or directory) where to write the data.","title":"write"},{"location":"reference/koswat_docstrings/core/io.html#csv-module","text":"","title":"CSV module"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.csv.koswat_csv_fom_protocol.KoswatCsvFomProtocol","text":"Bases: FileObjectModelProtocol , Protocol","title":"KoswatCsvFomProtocol"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.csv.koswat_csv_fom_protocol.KoswatCsvFomProtocol.is_valid","text":"Validates the current structure of this KoswatCsvFomProtocol instance. Returns: bool ( bool ) \u2013 True when is a valid FOM.","title":"is_valid"},{"location":"reference/koswat_docstrings/core/io.html#ini-module","text":"","title":"INI module"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.ini.koswat_ini_fom_protocol.KoswatIniFomProtocol","text":"Bases: FileObjectModelProtocol , Protocol","title":"KoswatIniFomProtocol"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.ini.koswat_ini_fom_protocol.KoswatIniFomProtocol.from_config","text":"Imports all the data stored in an dictionary into a KoswatIniFomProtocol instance. Parameters: ini_config ( ConfigParser ) \u2013 Dictionary containing Ini values (section - properties, property - value) to be parsed. Returns: KoswatIniFomProtocol ( KoswatIniFomProtocol ) \u2013 Valid instance of a KoswatIniFomProtocol with the provided values.","title":"from_config"},{"location":"reference/koswat_docstrings/core/io.html#txt-module","text":"","title":"TXT module"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.txt.koswat_txt_fom_protocol.KoswatTxtFomProtocol","text":"Bases: FileObjectModelProtocol , Protocol","title":"KoswatTxtFomProtocol"},{"location":"reference/koswat_docstrings/core/io.html#koswat.core.io.txt.koswat_txt_fom_protocol.KoswatTxtFomProtocol.from_text","text":"Imports all the data stored in text form. Parameters: file_text ( str ) \u2013 Raw data in string format. Returns: KoswatTxtFomProtocol ( KoswatTxtFomProtocol ) \u2013 Valid instance of a KoswatTxtFomProtocol with the provided values.","title":"from_text"},{"location":"reference/koswat_docstrings/core/koswat_logger.html","text":"Koswat logger \u00b6 KoswatLogger \u00b6","title":"Koswat logger"},{"location":"reference/koswat_docstrings/core/koswat_logger.html#koswat-logger","text":"","title":"Koswat logger"},{"location":"reference/koswat_docstrings/core/koswat_logger.html#koswat.core.koswat_logger.KoswatLogger","text":"","title":"KoswatLogger"},{"location":"reference/koswat_docstrings/core/protocols.html","text":"Core protocols module \u00b6 BuilderProtocol \u00b6 Bases: Protocol build () -> Any \u00b6 Instantiates a concrete object to separate its initalization from the data structure. Returns: Any ( Any ) \u2013 Intance of a created object within Koswat domain. DataObjectModelProtocol \u00b6 Bases: Protocol Empty protocol just to be able to classify other classes as a DataObjectModelProtocol Instance.","title":"Core protocols module"},{"location":"reference/koswat_docstrings/core/protocols.html#core-protocols-module","text":"","title":"Core protocols module"},{"location":"reference/koswat_docstrings/core/protocols.html#koswat.core.protocols.builder_protocol.BuilderProtocol","text":"Bases: Protocol","title":"BuilderProtocol"},{"location":"reference/koswat_docstrings/core/protocols.html#koswat.core.protocols.builder_protocol.BuilderProtocol.build","text":"Instantiates a concrete object to separate its initalization from the data structure. Returns: Any ( Any ) \u2013 Intance of a created object within Koswat domain.","title":"build"},{"location":"reference/koswat_docstrings/core/protocols.html#koswat.core.protocols.data_object_model_protocol.DataObjectModelProtocol","text":"Bases: Protocol Empty protocol just to be able to classify other classes as a DataObjectModelProtocol Instance.","title":"DataObjectModelProtocol"},{"location":"reference/koswat_docstrings/dike/layers.html","text":"Dike layers module. \u00b6 KoswatLayerBuilderProtocol \u00b6 Bases: BuilderProtocol , Protocol build () -> KoswatLayerProtocol \u00b6 Builds an instance of a KoswatLayerProtocol based on the provided upper_linestring and layer_data Returns: KoswatLayerProtocol ( KoswatLayerProtocol ) \u2013 Valid instance of a KoswatLayerProtocol . KoswatLayerProtocol \u00b6 Bases: Protocol as_data_dict () -> dict \u00b6 Returns the information related to an instance of the KoswatLayerProtocol . Returns: dict ( dict ) \u2013 custom dictionary with the relevant data. Layers wrapper \u00b6 KoswatLayersWrapperBuilderProtocol \u00b6 Bases: BuilderProtocol , Protocol build () -> KoswatLayersWrapperProtocol \u00b6 Builds an instance of KoswatLayersWrapperProtocol based on the class required fields layers_data and profile_points . Returns: KoswatLayersWrapperProtocol ( KoswatLayersWrapperProtocol ) \u2013 Valid initialized instance of a KoswatLayersWrapperProtocol . KoswatLayersWrapperProtocol \u00b6 Bases: Protocol as_data_dict () -> dict \u00b6 Returns the layers as a dictionary. Returns: dict ( dict ) \u2013 Dictionary containing all the information of the wrapper layers ( KoswatLayerProtocol ).","title":"Dike layers module."},{"location":"reference/koswat_docstrings/dike/layers.html#dike-layers-module","text":"","title":"Dike layers module."},{"location":"reference/koswat_docstrings/dike/layers.html#koswat.dike.layers.koswat_layer_builder_protocol.KoswatLayerBuilderProtocol","text":"Bases: BuilderProtocol , Protocol","title":"KoswatLayerBuilderProtocol"},{"location":"reference/koswat_docstrings/dike/layers.html#koswat.dike.layers.koswat_layer_builder_protocol.KoswatLayerBuilderProtocol.build","text":"Builds an instance of a KoswatLayerProtocol based on the provided upper_linestring and layer_data Returns: KoswatLayerProtocol ( KoswatLayerProtocol ) \u2013 Valid instance of a KoswatLayerProtocol .","title":"build"},{"location":"reference/koswat_docstrings/dike/layers.html#koswat.dike.layers.koswat_layer_protocol.KoswatLayerProtocol","text":"Bases: Protocol","title":"KoswatLayerProtocol"},{"location":"reference/koswat_docstrings/dike/layers.html#koswat.dike.layers.koswat_layer_protocol.KoswatLayerProtocol.as_data_dict","text":"Returns the information related to an instance of the KoswatLayerProtocol . Returns: dict ( dict ) \u2013 custom dictionary with the relevant data.","title":"as_data_dict"},{"location":"reference/koswat_docstrings/dike/layers.html#layers-wrapper","text":"","title":"Layers wrapper"},{"location":"reference/koswat_docstrings/dike/layers.html#koswat.dike.layers.layers_wrapper.koswat_layers_wrapper_builder_protocol.KoswatLayersWrapperBuilderProtocol","text":"Bases: BuilderProtocol , Protocol","title":"KoswatLayersWrapperBuilderProtocol"},{"location":"reference/koswat_docstrings/dike/layers.html#koswat.dike.layers.layers_wrapper.koswat_layers_wrapper_builder_protocol.KoswatLayersWrapperBuilderProtocol.build","text":"Builds an instance of KoswatLayersWrapperProtocol based on the class required fields layers_data and profile_points . Returns: KoswatLayersWrapperProtocol ( KoswatLayersWrapperProtocol ) \u2013 Valid initialized instance of a KoswatLayersWrapperProtocol .","title":"build"},{"location":"reference/koswat_docstrings/dike/layers.html#koswat.dike.layers.layers_wrapper.koswat_layers_wrapper_protocol.KoswatLayersWrapperProtocol","text":"Bases: Protocol","title":"KoswatLayersWrapperProtocol"},{"location":"reference/koswat_docstrings/dike/layers.html#koswat.dike.layers.layers_wrapper.koswat_layers_wrapper_protocol.KoswatLayersWrapperProtocol.as_data_dict","text":"Returns the layers as a dictionary. Returns: dict ( dict ) \u2013 Dictionary containing all the information of the wrapper layers ( KoswatLayerProtocol ).","title":"as_data_dict"},{"location":"reference/koswat_docstrings/dike/profile.html","text":"Koswat dike profile module \u00b6 KoswatProfileBase dataclass \u00b6 Bases: KoswatProfileProtocol Basic definition and implementation of a KoswatProfileProtocol . It represents the initial koswat profile being provided by the user from which further calculations will be made. points : list [ Point ] property \u00b6 The combination of points from both water and polder sides. Returns: list [ Point ] \u2013 list[Point]: A total of eight points comforming the KoswatProfile . profile_height : float property \u00b6 The profile highest point (largest y-coordinate). Returns: float ( float ) \u2013 Greatest y-coordinate. profile_width : float property \u00b6 The profile extent from the lowest (left-most) x-coordinate to the largest (right-most) x-coordinate from a dike geometry polygon. Returns: float ( float ) \u2013 Total distance.","title":"Koswat dike profile module"},{"location":"reference/koswat_docstrings/dike/profile.html#koswat-dike-profile-module","text":"","title":"Koswat dike profile module"},{"location":"reference/koswat_docstrings/dike/profile.html#koswat.dike.profile.koswat_profile.KoswatProfileBase","text":"Bases: KoswatProfileProtocol Basic definition and implementation of a KoswatProfileProtocol . It represents the initial koswat profile being provided by the user from which further calculations will be made.","title":"KoswatProfileBase"},{"location":"reference/koswat_docstrings/dike/profile.html#koswat.dike.profile.koswat_profile.KoswatProfileBase.points","text":"The combination of points from both water and polder sides. Returns: list [ Point ] \u2013 list[Point]: A total of eight points comforming the KoswatProfile .","title":"points"},{"location":"reference/koswat_docstrings/dike/profile.html#koswat.dike.profile.koswat_profile.KoswatProfileBase.profile_height","text":"The profile highest point (largest y-coordinate). Returns: float ( float ) \u2013 Greatest y-coordinate.","title":"profile_height"},{"location":"reference/koswat_docstrings/dike/profile.html#koswat.dike.profile.koswat_profile.KoswatProfileBase.profile_width","text":"The profile extent from the lowest (left-most) x-coordinate to the largest (right-most) x-coordinate from a dike geometry polygon. Returns: float ( float ) \u2013 Total distance.","title":"profile_width"},{"location":"reference/koswat_docstrings/dike/surroundings.html","text":"Koswat dike surroundings \u00b6 KoswatSurroundingsProtocol \u00b6 Bases: Protocol Empty interface to represent the Koswat surroundings and easily identify them throughout the solution. SurroundingsInfrastructure dataclass \u00b6 Bases: KoswatSurroundingsProtocol Defines surroundings point collections that can be repaired or replaced. The PointSurroundings contain a matrix (dictionary) where the keys represent the distances to an obstacle, and the values a float representing how long that infrastructure is. SurroundingsObstacle dataclass \u00b6 Bases: KoswatSurroundingsProtocol Defines surroundings point collections that cannot be repaired or replaced. The PointObstacleSurroundings contain the closest distance to an obstacle both inside and outside the polder. Point \u00b6 PointSurroundings dataclass \u00b6 Object representing a meter with x , y coordinates in a polder (or else). __eq__ ( __value : object ) -> bool \u00b6 Overriding of the \"magic\" equality operator required so that PointSurroundings can be used as a key in a python dict. __hash__ () -> int \u00b6 Overriding of the \"magic\" hash operator required so that PointSurroundings can be used as a key in a python dict. get_total_infrastructure_per_zone ( * zone_limit_collection : tuple [ float , float ]) -> list [ float ] \u00b6 Gets the total infrastructure width at each of the provided zones zone_limit_collection ( tuple[float, float] ). The zone limits are matched by rounding up their upper limit to the surroundings_matrix keys (distances to the location in the real world). When two zones have overlapping limits (as expected) the lower one will \"claim\" the corresponding surrounding distance. Example zone_limit_collection = (0, 4), (4, 11) surroundings_matrix = {5: 1.5, 10: 3, 15: 6} \"Taken\" distances per zone: (0, 4) takes key 5 . (4, 11) takes key(s) 10 and 15 because 5 was already taken. Total infrastructure width at zones = (1.5, 9) Returns: list [ float ] \u2013 list[float]: list with total width corresponding to each provided zone. merge ( other : PointSurroundings ) -> None \u00b6 Merges another PointSurroundings into this one by updating the surroundings_matrix with the values from the other one. Parameters: other ( PointSurroundings ) \u2013 The other PointSurroundings to merge. PointSurroundingsListBuilder dataclass \u00b6 Bases: BuilderProtocol Builds a collection of points ( list[PointSurroundings] ) given the dike locations ( KoswatDikeLocationsShpFom ) and the surroundings around it ( KoswatSurroundingsCsvFom ). Wrapper \u00b6 SurroundingsWrapper dataclass \u00b6 get_locations_at_safe_distance ( distance : float ) -> list [ PointSurroundings ] \u00b6 Gets all locations which are safe from obstacle surroundings in a radius of distance . Parameters: distance ( float ) \u2013 Radius from each point that should be free of surroundings. Returns: list [ PointSurroundings ] \u2013 List[PointSurroundings]: List of safe locations (points with surroundings). ObstacleSurroundingsWrapper dataclass \u00b6 Bases: BaseSurroundingsWrapper get_locations_at_safe_distance ( distance : float ) -> list [ PointSurroundings ] \u00b6 Gets all locations which are safe from obstacle surroundings in a radius of distance . Parameters: distance ( float ) \u2013 Radius from each point that should be free of surroundings. Returns: list [ PointSurroundings ] \u2013 list[PointSurroundings]: List of safe locations (points with surroundings). obstacle_locations : list [ PointObstacleSurroundings ] property \u00b6 Overlay of locations of the different ObstacleSurroundings that are present. Buildings need to be present as input (leading for location coordinates). Each location represents 1 meter in a real scale map. Returns: list [ PointObstacleSurroundings ] \u2013 list[PointSurroundings]: List of locations with only the closest distance to obstacle(s).","title":"Koswat dike surroundings"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat-dike-surroundings","text":"","title":"Koswat dike surroundings"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.koswat_surroundings_protocol.KoswatSurroundingsProtocol","text":"Bases: Protocol Empty interface to represent the Koswat surroundings and easily identify them throughout the solution.","title":"KoswatSurroundingsProtocol"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.surroundings_infrastructure.SurroundingsInfrastructure","text":"Bases: KoswatSurroundingsProtocol Defines surroundings point collections that can be repaired or replaced. The PointSurroundings contain a matrix (dictionary) where the keys represent the distances to an obstacle, and the values a float representing how long that infrastructure is.","title":"SurroundingsInfrastructure"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.surroundings_obstacle.SurroundingsObstacle","text":"Bases: KoswatSurroundingsProtocol Defines surroundings point collections that cannot be repaired or replaced. The PointObstacleSurroundings contain the closest distance to an obstacle both inside and outside the polder.","title":"SurroundingsObstacle"},{"location":"reference/koswat_docstrings/dike/surroundings.html#point","text":"","title":"Point"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.point.point_surroundings.PointSurroundings","text":"Object representing a meter with x , y coordinates in a polder (or else).","title":"PointSurroundings"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.point.point_surroundings.PointSurroundings.__eq__","text":"Overriding of the \"magic\" equality operator required so that PointSurroundings can be used as a key in a python dict.","title":"__eq__"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.point.point_surroundings.PointSurroundings.__hash__","text":"Overriding of the \"magic\" hash operator required so that PointSurroundings can be used as a key in a python dict.","title":"__hash__"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.point.point_surroundings.PointSurroundings.get_total_infrastructure_per_zone","text":"Gets the total infrastructure width at each of the provided zones zone_limit_collection ( tuple[float, float] ). The zone limits are matched by rounding up their upper limit to the surroundings_matrix keys (distances to the location in the real world). When two zones have overlapping limits (as expected) the lower one will \"claim\" the corresponding surrounding distance. Example zone_limit_collection = (0, 4), (4, 11) surroundings_matrix = {5: 1.5, 10: 3, 15: 6} \"Taken\" distances per zone: (0, 4) takes key 5 . (4, 11) takes key(s) 10 and 15 because 5 was already taken. Total infrastructure width at zones = (1.5, 9) Returns: list [ float ] \u2013 list[float]: list with total width corresponding to each provided zone.","title":"get_total_infrastructure_per_zone"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.point.point_surroundings.PointSurroundings.merge","text":"Merges another PointSurroundings into this one by updating the surroundings_matrix with the values from the other one. Parameters: other ( PointSurroundings ) \u2013 The other PointSurroundings to merge.","title":"merge"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.point.point_surroundings_list_polderside_builder.PointSurroundingsListBuilder","text":"Bases: BuilderProtocol Builds a collection of points ( list[PointSurroundings] ) given the dike locations ( KoswatDikeLocationsShpFom ) and the surroundings around it ( KoswatSurroundingsCsvFom ).","title":"PointSurroundingsListBuilder"},{"location":"reference/koswat_docstrings/dike/surroundings.html#wrapper","text":"","title":"Wrapper"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.wrapper.surroundings_wrapper.SurroundingsWrapper","text":"","title":"SurroundingsWrapper"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.wrapper.surroundings_wrapper.SurroundingsWrapper.get_locations_at_safe_distance","text":"Gets all locations which are safe from obstacle surroundings in a radius of distance . Parameters: distance ( float ) \u2013 Radius from each point that should be free of surroundings. Returns: list [ PointSurroundings ] \u2013 List[PointSurroundings]: List of safe locations (points with surroundings).","title":"get_locations_at_safe_distance"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.wrapper.obstacle_surroundings_wrapper.ObstacleSurroundingsWrapper","text":"Bases: BaseSurroundingsWrapper","title":"ObstacleSurroundingsWrapper"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.wrapper.obstacle_surroundings_wrapper.ObstacleSurroundingsWrapper.get_locations_at_safe_distance","text":"Gets all locations which are safe from obstacle surroundings in a radius of distance . Parameters: distance ( float ) \u2013 Radius from each point that should be free of surroundings. Returns: list [ PointSurroundings ] \u2013 list[PointSurroundings]: List of safe locations (points with surroundings).","title":"get_locations_at_safe_distance"},{"location":"reference/koswat_docstrings/dike/surroundings.html#koswat.dike.surroundings.wrapper.obstacle_surroundings_wrapper.ObstacleSurroundingsWrapper.obstacle_locations","text":"Overlay of locations of the different ObstacleSurroundings that are present. Buildings need to be present as input (leading for location coordinates). Each location represents 1 meter in a real scale map. Returns: list [ PointObstacleSurroundings ] \u2013 list[PointSurroundings]: List of locations with only the closest distance to obstacle(s).","title":"obstacle_locations"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_layers.html","text":"Reinforcement Layers Wrapper \u00b6 ReinforcementCoatingLayer \u00b6 Bases: ReinforcementLayerProtocol with_same_outer_geometry ( coating_layer : KoswatCoatingLayer ) -> ReinforcementCoatingLayer classmethod \u00b6 Creates a new reinforcement coating layer which does not differ in geometry from the provided coating layer. This was found to be needed in KOSWAT_82. Parameters: coating_layer ( KoswatCoatingLayer ) \u2013 Base coating layer. Returns: ReinforcementCoatingLayer ( ReinforcementCoatingLayer ) \u2013 Resulting coating layer with \"empty\" ReinforcementCoatingLayer \u2013 polygons for added / removed (layer) geometries. ReinforcementLayersWrapper \u00b6 Bases: KoswatLayersWrapperProtocol layers : list [ ReinforcementLayerProtocol ] property \u00b6 All the stored layers being the KoswatBaseLayer the latest one in the collection. Returns: list [ ReinforcementLayerProtocol ] \u2013 List[KoswatLayerProtocol]: Ordered list of KoswatLayerProtocol . OutsideSlopeReinforcementLayersWrapperBuilder \u00b6 Bases: KoswatLayersWrapperBuilderProtocol StandardReinforcementLayersWrapperBuilder \u00b6 Bases: KoswatLayersWrapperBuilderProtocol","title":"Reinforcement Layers Wrapper"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_layers.html#reinforcement-layers-wrapper","text":"","title":"Reinforcement Layers Wrapper"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_layers.html#koswat.dike_reinforcements.reinforcement_layers.reinforcement_coating_layer.ReinforcementCoatingLayer","text":"Bases: ReinforcementLayerProtocol","title":"ReinforcementCoatingLayer"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_layers.html#koswat.dike_reinforcements.reinforcement_layers.reinforcement_coating_layer.ReinforcementCoatingLayer.with_same_outer_geometry","text":"Creates a new reinforcement coating layer which does not differ in geometry from the provided coating layer. This was found to be needed in KOSWAT_82. Parameters: coating_layer ( KoswatCoatingLayer ) \u2013 Base coating layer. Returns: ReinforcementCoatingLayer ( ReinforcementCoatingLayer ) \u2013 Resulting coating layer with \"empty\" ReinforcementCoatingLayer \u2013 polygons for added / removed (layer) geometries.","title":"with_same_outer_geometry"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_layers.html#koswat.dike_reinforcements.reinforcement_layers.reinforcement_layers_wrapper.ReinforcementLayersWrapper","text":"Bases: KoswatLayersWrapperProtocol","title":"ReinforcementLayersWrapper"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_layers.html#koswat.dike_reinforcements.reinforcement_layers.reinforcement_layers_wrapper.ReinforcementLayersWrapper.layers","text":"All the stored layers being the KoswatBaseLayer the latest one in the collection. Returns: list [ ReinforcementLayerProtocol ] \u2013 List[KoswatLayerProtocol]: Ordered list of KoswatLayerProtocol .","title":"layers"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_layers.html#koswat.dike_reinforcements.reinforcement_layers.outside_slope_reinforcement_layers_wrapper_builder.OutsideSlopeReinforcementLayersWrapperBuilder","text":"Bases: KoswatLayersWrapperBuilderProtocol","title":"OutsideSlopeReinforcementLayersWrapperBuilder"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_layers.html#koswat.dike_reinforcements.reinforcement_layers.standard_reinforcement_layers_wrapper_builder.StandardReinforcementLayersWrapperBuilder","text":"Bases: KoswatLayersWrapperBuilderProtocol","title":"StandardReinforcementLayersWrapperBuilder"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html","text":"Reinforcement profile \u00b6 ReinforcementProfileBuilderFactory \u00b6 get_available_reinforcements () -> list [ ReinforcementProfileProtocol ] staticmethod \u00b6 Gets all available reinforcements defined in Koswat. Returns: list [ ReinforcementProfileProtocol ] \u2013 List[ReinforcementProfileProtocol]: List of reinforcement profile protocols types. get_reinforcement_builder ( reinforcement_profile_type : type [ ReinforcementProfileProtocol ]) -> ReinforcementProfileBuilderProtocol staticmethod \u00b6 Gets a valid reinforcement profile builder instance ( ReinforcementProfileBuilderProtocol ). Parameters: reinforcement_profile_type ( Type [ ReinforcementProfileProtocol ] ) \u2013 Type that requires a builder. Raises: NotImplementedError \u2013 When there is no builder associated to the given reinforcement_profile_type . Returns: ReinforcementProfileBuilderProtocol ( ReinforcementProfileBuilderProtocol ) \u2013 Valid instance of a ReinforcementProfileBuilderProtocol . ReinforcementProfileBuilderProtocol \u00b6 Bases: BuilderProtocol , Protocol build () -> ReinforcementProfileProtocol \u00b6 Builds a concrete instance of a ReinforcementProfileProtocol based on the required data. Returns: ReinforcementProfileProtocol ( ReinforcementProfileProtocol ) \u2013 Valid instance of a ReinforcementProfileProtocol . ReinforcementProfileProtocol \u00b6 Bases: KoswatProfileProtocol , Protocol Extension of the KoswatProfileProtocol to define the properties of a calculated reinforcement. Outside slope \u00b6 Standard \u00b6 StandardReinforcementProfileBuilder \u00b6 Bases: ReinforcementProfileBuilderBase get_input_profile_calculator ( reinforcement_type : type [ StandardReinforcementProfile ]) -> ReinforcementInputProfileCalculationProtocol staticmethod \u00b6 Get the input profile calculator for the given reinforcement type. Parameters: reinforcement_type ( type [ StandardReinforcementProfile ] ) \u2013 The reinforcement type. Raises: NotImplementedError \u2013 The given reinforcement type is not supported. Returns: ReinforcementInputProfileCalculationProtocol ( ReinforcementInputProfileCalculationProtocol ) \u2013 The input profile calculator.","title":"Reinforcement profile"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#reinforcement-profile","text":"","title":"Reinforcement profile"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#koswat.dike_reinforcements.reinforcement_profile.reinforcement_profile_builder_factory.ReinforcementProfileBuilderFactory","text":"","title":"ReinforcementProfileBuilderFactory"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#koswat.dike_reinforcements.reinforcement_profile.reinforcement_profile_builder_factory.ReinforcementProfileBuilderFactory.get_available_reinforcements","text":"Gets all available reinforcements defined in Koswat. Returns: list [ ReinforcementProfileProtocol ] \u2013 List[ReinforcementProfileProtocol]: List of reinforcement profile protocols types.","title":"get_available_reinforcements"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#koswat.dike_reinforcements.reinforcement_profile.reinforcement_profile_builder_factory.ReinforcementProfileBuilderFactory.get_reinforcement_builder","text":"Gets a valid reinforcement profile builder instance ( ReinforcementProfileBuilderProtocol ). Parameters: reinforcement_profile_type ( Type [ ReinforcementProfileProtocol ] ) \u2013 Type that requires a builder. Raises: NotImplementedError \u2013 When there is no builder associated to the given reinforcement_profile_type . Returns: ReinforcementProfileBuilderProtocol ( ReinforcementProfileBuilderProtocol ) \u2013 Valid instance of a ReinforcementProfileBuilderProtocol .","title":"get_reinforcement_builder"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#koswat.dike_reinforcements.reinforcement_profile.reinforcement_profile_builder_protocol.ReinforcementProfileBuilderProtocol","text":"Bases: BuilderProtocol , Protocol","title":"ReinforcementProfileBuilderProtocol"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#koswat.dike_reinforcements.reinforcement_profile.reinforcement_profile_builder_protocol.ReinforcementProfileBuilderProtocol.build","text":"Builds a concrete instance of a ReinforcementProfileProtocol based on the required data. Returns: ReinforcementProfileProtocol ( ReinforcementProfileProtocol ) \u2013 Valid instance of a ReinforcementProfileProtocol .","title":"build"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#koswat.dike_reinforcements.reinforcement_profile.reinforcement_profile_protocol.ReinforcementProfileProtocol","text":"Bases: KoswatProfileProtocol , Protocol Extension of the KoswatProfileProtocol to define the properties of a calculated reinforcement.","title":"ReinforcementProfileProtocol"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#outside-slope","text":"","title":"Outside slope"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#standard","text":"","title":"Standard"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#koswat.dike_reinforcements.reinforcement_profile.standard.standard_reinforcement_profile_builder.StandardReinforcementProfileBuilder","text":"Bases: ReinforcementProfileBuilderBase","title":"StandardReinforcementProfileBuilder"},{"location":"reference/koswat_docstrings/dike_reinforcements/reinforcement_profile.html#koswat.dike_reinforcements.reinforcement_profile.standard.standard_reinforcement_profile_builder.StandardReinforcementProfileBuilder.get_input_profile_calculator","text":"Get the input profile calculator for the given reinforcement type. Parameters: reinforcement_type ( type [ StandardReinforcementProfile ] ) \u2013 The reinforcement type. Raises: NotImplementedError \u2013 The given reinforcement type is not supported. Returns: ReinforcementInputProfileCalculationProtocol ( ReinforcementInputProfileCalculationProtocol ) \u2013 The input profile calculator.","title":"get_input_profile_calculator"},{"location":"reference/koswat_docstrings/plots/dike.html","text":"Dike plotting module \u00b6 KoswatLayerPlot \u00b6 Bases: KoswatPlotProtocol plot ( color : str ) -> None \u00b6 Plots a KoswatLayerProtocol into the provided canvas plot_axes with the requested color . Parameters: color ( str ) \u2013 Color code. return list( map(concatenate, zip(*map(lambda x: x.coords.xy, koswat_geometry.geoms))) ) ValueError: When the KoswatLayerProtocol material has not been registered. KoswatLayersWrapperPlot \u00b6 Bases: KoswatPlotProtocol with_layers_list ( layers_list : list [ KoswatLayerProtocol ]) -> KoswatLayersWrapperPlot classmethod \u00b6 Class method to aid the usage of this class with unrelated layers from different wrappers. Parameters: layers_list ( list [ KoswatLayerProtocol ] ) \u2013 List of layers to wrap just for plotting. Returns: KoswatLayersWrapperPlot ( KoswatLayersWrapperPlot ) \u2013 Initialized valid instance with custom intenal wrapper PlotLayersWrapper .","title":"Dike plotting module"},{"location":"reference/koswat_docstrings/plots/dike.html#dike-plotting-module","text":"","title":"Dike plotting module"},{"location":"reference/koswat_docstrings/plots/dike.html#koswat.plots.dike.koswat_layer_plot.KoswatLayerPlot","text":"Bases: KoswatPlotProtocol","title":"KoswatLayerPlot"},{"location":"reference/koswat_docstrings/plots/dike.html#koswat.plots.dike.koswat_layer_plot.KoswatLayerPlot.plot","text":"Plots a KoswatLayerProtocol into the provided canvas plot_axes with the requested color . Parameters: color ( str ) \u2013 Color code. return list( map(concatenate, zip(*map(lambda x: x.coords.xy, koswat_geometry.geoms))) ) ValueError: When the KoswatLayerProtocol material has not been registered.","title":"plot"},{"location":"reference/koswat_docstrings/plots/dike.html#koswat.plots.dike.koswat_layers_wrapper_plot.KoswatLayersWrapperPlot","text":"Bases: KoswatPlotProtocol","title":"KoswatLayersWrapperPlot"},{"location":"reference/koswat_docstrings/plots/dike.html#koswat.plots.dike.koswat_layers_wrapper_plot.KoswatLayersWrapperPlot.with_layers_list","text":"Class method to aid the usage of this class with unrelated layers from different wrappers. Parameters: layers_list ( list [ KoswatLayerProtocol ] ) \u2013 List of layers to wrap just for plotting. Returns: KoswatLayersWrapperPlot ( KoswatLayersWrapperPlot ) \u2013 Initialized valid instance with custom intenal wrapper PlotLayersWrapper .","title":"with_layers_list"},{"location":"reference/koswat_docstrings/plots/geometries.html","text":"Geometries plot module \u00b6 HighlightGeometryPlot \u00b6 Bases: KoswatPlotProtocol plot ( * args , ** kwargs ) -> pyplot . axes \u00b6 Plots a layer highlighting its content. Returns: axes \u2013 pyplot.axes: Polygon with its area painted.","title":"Geometries plot module"},{"location":"reference/koswat_docstrings/plots/geometries.html#geometries-plot-module","text":"","title":"Geometries plot module"},{"location":"reference/koswat_docstrings/plots/geometries.html#koswat.plots.geometries.highlight_geometry_plot.HighlightGeometryPlot","text":"Bases: KoswatPlotProtocol","title":"HighlightGeometryPlot"},{"location":"reference/koswat_docstrings/plots/geometries.html#koswat.plots.geometries.highlight_geometry_plot.HighlightGeometryPlot.plot","text":"Plots a layer highlighting its content. Returns: axes \u2013 pyplot.axes: Polygon with its area painted.","title":"plot"},{"location":"reference/koswat_docstrings/plots/plots.html","text":"Plots module \u00b6 KoswatFigureContextHandler \u00b6 PyPlot fig context handler that opens the figure stream and closes it saving it to the appointed path. Usage example: with KoswatFigureContext(Path(\"C://my_plot.png\"), 42) as _figure: _subplot = _figure.add_subplot() ... __enter__ () -> Figure \u00b6 Access to the context and invokation of pyplot.figure(dpi) . Returns: Figure ( Figure ) \u2013 Initialized instance from pyplot.figure(dpi=dpi) . __exit__ ( * args , ** kwargs ) -> None \u00b6 Exit the current context and save the previously initialized Figure . __init__ ( output_path : Path , dpi : int ) -> None \u00b6 Initializes the context by invoking pyplot.figure(dpi=dpi) and saving its output to an internal field. Parameters: output_path ( Path ) \u2013 Export location for the generated plot. dpi ( int ) \u2013 Canvas resolution in dots-per-inch. KoswatPlotProtocol \u00b6 Bases: Protocol plot ( * args , ** kwargs ) -> pyplot . axes \u00b6 Plots a koswat_object into the provided plot ax with the requested *args and **kwargs . Returns: axes \u2013 pyplot.axes: Canvas with plotted koswat_object . PlotExporterProtocol \u00b6 Bases: KoswatExporterProtocol , Protocol export () -> None \u00b6 Exports a given object into a plot.","title":"Plots module"},{"location":"reference/koswat_docstrings/plots/plots.html#plots-module","text":"","title":"Plots module"},{"location":"reference/koswat_docstrings/plots/plots.html#koswat.plots.koswat_figure_context_handler.KoswatFigureContextHandler","text":"PyPlot fig context handler that opens the figure stream and closes it saving it to the appointed path. Usage example: with KoswatFigureContext(Path(\"C://my_plot.png\"), 42) as _figure: _subplot = _figure.add_subplot() ...","title":"KoswatFigureContextHandler"},{"location":"reference/koswat_docstrings/plots/plots.html#koswat.plots.koswat_figure_context_handler.KoswatFigureContextHandler.__enter__","text":"Access to the context and invokation of pyplot.figure(dpi) . Returns: Figure ( Figure ) \u2013 Initialized instance from pyplot.figure(dpi=dpi) .","title":"__enter__"},{"location":"reference/koswat_docstrings/plots/plots.html#koswat.plots.koswat_figure_context_handler.KoswatFigureContextHandler.__exit__","text":"Exit the current context and save the previously initialized Figure .","title":"__exit__"},{"location":"reference/koswat_docstrings/plots/plots.html#koswat.plots.koswat_figure_context_handler.KoswatFigureContextHandler.__init__","text":"Initializes the context by invoking pyplot.figure(dpi=dpi) and saving its output to an internal field. Parameters: output_path ( Path ) \u2013 Export location for the generated plot. dpi ( int ) \u2013 Canvas resolution in dots-per-inch.","title":"__init__"},{"location":"reference/koswat_docstrings/plots/plots.html#koswat.plots.koswat_plot_protocol.KoswatPlotProtocol","text":"Bases: Protocol","title":"KoswatPlotProtocol"},{"location":"reference/koswat_docstrings/plots/plots.html#koswat.plots.koswat_plot_protocol.KoswatPlotProtocol.plot","text":"Plots a koswat_object into the provided plot ax with the requested *args and **kwargs . Returns: axes \u2013 pyplot.axes: Canvas with plotted koswat_object .","title":"plot"},{"location":"reference/koswat_docstrings/plots/plots.html#koswat.plots.plot_exporter_protocol.PlotExporterProtocol","text":"Bases: KoswatExporterProtocol , Protocol","title":"PlotExporterProtocol"},{"location":"reference/koswat_docstrings/plots/plots.html#koswat.plots.plot_exporter_protocol.PlotExporterProtocol.export","text":"Exports a given object into a plot.","title":"export"}]}